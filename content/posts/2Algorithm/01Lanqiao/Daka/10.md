---
title: 【打卡】第十天
weight: 10
date: 2025-12-07T20:06:00+08:00
---

## P8808 [蓝桥杯 2022 国 C] 斐波那契数组
> [点击此处跳转](https://www.luogu.com.cn/problem/P8808)

> [!NOTE] 知识点
> 斐波那契数列、哈希表（桶计数）

题目要求我们通过最少的修改次数，将数组 $A$ 变为一个斐波那契数组。
斐波那契数组的定义是 $a_0 = a_1$，且 $a_i = a_{i-1} + a_{i-2}$。
这实际上意味着，整个数组完全由起始的第一项（或者说公因数）$k$ 决定。
标准的斐波那契数列 $F$ 为：$1, 1, 2, 3, 5, 8, \dots$
那么任何合法的斐波那契数组 $A'$ 都可以表示为：$k\times 1, k\times 1, k\times 2, k\times 3, \dots$
即 $A'[i] = k \times F[i]$。

**解题思路：**
我们要让保留的数字最多（修改的最少），即寻找一个 $k$，使得满足 $A[i] = k \times F[i]$ 的下标 $i$ 的数量最多。
由公式可得 $k = A[i] / F[i]$。
因此，我们可以遍历输入数组 $A$，对于每一个元素 $A[i]$，计算它对应的 $k$ 值。如果 $A[i]$ 能被当前的斐波那契数 $F[i]$ 整除，说明这个数字“可能”属于以 $k$ 开头的斐波那契数组，我们在桶中记录 $k$ 出现的次数。


> [!SUCCESS] Code
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 题目给定 ai 最大值为 10^6
const int MAX_VAL = 1000000;
// 用于统计 k 出现次数的桶
int counts[MAX_VAL + 1];

int main() {
    // 开启输入输出加速
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);

    int n;
    if (!(std::cin >> n)) return 0;

    // 斐波那契数列初始化
    // f_curr 代表 F[i], f_prev 代表 F[i-1]
    // 序列: 1, 1, 2, 3, 5...
    int f_curr = 1; 
    int f_prev = 0; 

    int max_match = 0; // 记录同一个 k 匹配到的最大次数

    for (int i = 0; i < n; ++i) {
        int a;
        std::cin >> a;

        // 核心剪枝：如果标准斐波那契数已经超过了题目允许的最大值，
        // 那么不可能存在 k >= 1 使得 k * F[i] == a (a <= 10^6)
        // 所以只有当 f_curr 在范围内时才进行检查
        if (f_curr <= MAX_VAL) {
            // 检查当前数字能否由 k * F[i] 得到
            if (a % f_curr == 0) {
                int k = a / f_curr;
                // k 也必须在合理范围内（虽然由 a/f_curr 算出通常不会越界，但作为桶索引需安全）
                if (k <= MAX_VAL) {
                    counts[k]++;
                    max_match = std::max(max_match, counts[k]);
                }
            }
            
            // 更新斐波那契数列
            int next_val = f_curr + f_prev;
            f_prev = f_curr;
            f_curr = next_val;
        }
        // 如果 f_curr 已经超出范围，我们只需继续读取剩下的输入，不做处理
    }

    // 最小修改次数 = 总数 - 最多保留的个数
    std::cout << n - max_match << std::endl;

    return 0;
}
```

## P10910 [蓝桥杯 2024 国 B] 最小字符串

> [点击此处跳转](https://www.luogu.com.cn/problem/P10910)

> [!NOTE] 考点
> 贪心算法、排序

**解题思路：**

为了使构造出的字符串字典序最小，我们需要遵循“越小的字符越靠前”的原则。这实际上是一个将两个字符序列合并的问题：一个是固定的原字符串 $S$，另一个是可以在任意位置插入的字符集合 $C$。

1.  **预处理**：因为插入的位置任意，为了保证局部最优，我们一定是从小到大使用待插入的字符。所以，首先将 $M$ 个待插入字符进行**升序排序**。
2.  **贪心合并**：
    我们遍历原字符串 $S$，维护一个指针指向排序后的待插入数组 $C$ 的当前头部。对于 $S$ 中的每一个字符 $S[i]$：
      * **如果是 $C[j] < S[i]$**：说明待插入的字符比当前原串字符更小。为了让结果字典序更小，我们应该尽早输出这个较小的 $C[j]$，直到 $C[j] \ge S[i]$ 或者 $C$ 用完为止。
      * **如果是 $C[j] \ge S[i]$**：此时不能插入 $C[j]$。
          * 若 $C[j] > S[i]$，显然应该先输出较小的 $S[i]$。
          * 若 $C[j] == S[i]$，这里是贪心的关键。虽然当前字符相等，但 $C$ 是有序的（后面的只会更大或相等），而 $S$ 是无序的（$S[i+1]$ 可能会变小）。为了让 $S$ 后面潜在的更小字符尽快“露面”，我们必须**优先输出 $S[i]$**。
          * *例如：$S=$"ba", $C=$"b"。若先输 $C$ 得 "bba"，若先输 $S$ 得 "bab"。显然 "bab" \< "bba"（因为第二位 'a' \< 'b'）。*
3.  **收尾**：遍历完 $S$ 后，如果 $C$ 中还有剩余字符，直接全部接在字符串末尾。

> [!SUCCESS] Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int main() {
    // 优化 I/O 效率
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    if (!(std::cin >> n >> m)) return 0;

    std::string s;
    std::cin >> s;

    // 读入待插入字符并排序
    std::string to_insert;
    // 预分配空间避免多次扩容
    to_insert.reserve(m); 
    for (int i = 0; i < m; ++i) {
        char c;
        std::cin >> c;
        to_insert.push_back(c);
    }
    std::sort(to_insert.begin(), to_insert.end());

    int j = 0; // 指向 to_insert 的指针
    for (int i = 0; i < n; ++i) {
        // 贪心策略：如果待插入的字符严格小于当前原串字符，
        // 则先输出待插入字符，确立更小的字典序前缀。
        while (j < m && to_insert[j] < s[i]) {
            std::cout << to_insert[j];
            j++;
        }
        // 当 to_insert[j] >= s[i] 时，优先输出 s[i]
        // 特别是相等时，必须先消耗掉 s[i]，以便让 S 后面可能更小的字符尽快出现
        std::cout << s[i];
    }

    // 输出剩余的所有待插入字符
    while (j < m) {
        std::cout << to_insert[j];
        j++;
    }
    std::cout << std::endl;

    return 0;
}
```
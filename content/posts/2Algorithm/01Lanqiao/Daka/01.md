---
title: 【打卡】第一天
weight: 1
date: 2025-11-28T20:06:00+08:00
---

## P8772 [蓝桥杯 2022 省 A] 求和

> [点击此处跳转](https://www.luogu.com.cn/problem/P8772)

> [!NOTE] 知识点
> 前缀和

本题求解的S即数列的两两乘积和，最简单的写法莫过于直接写成两层循环,但是这样做时间复杂度为$O(n^2)$.

$$ S = \sum_{1 \le i \lt j \le n} a_ia_j $$ 

我们仔细看这个公式，还有一种理解方式是，**每一个$a_j$都要和$a_i(i < j)$相乘，这一部分相加就相当于$a_j$乘上一个前缀和**，对每一个$a_j$我们都做一遍这样的乘法，最后吧所有乘积相加就是答案，这样就可以省去一层循环。

> [!SUCCESS] Code
```cpp
#include<bits/stdc++.h>

int main() {
   int n; std::cin >> n;
   long long S = 0, prefix = 0, a = 0;
   for (int i = 0; i < n; i++) {
       std::cin >> a;
       S += a * prefix;
       prefix += a;
   }
   std::cout << S << std::endl;
   return 0;
}
```

## P8716 [蓝桥杯 2020 省 AB2] 回文日期
> [点击此处跳转](https://www.luogu.com.cn/problem/P8716)

> [!NOTE] 知识点
> 二分搜索

本题只给一个日期，让我们找到下一个回文日期和下一个`ababbaba`形的回文日期，或许不容易想到我这个思路，但若是有很多次提问呢？
我们肯定就容易想到**可以先生成所有可能的两种日期，然后用二分搜索找到答案啊~**

> [!SUCCESS] Code
```cpp
#include <bits/stdc++.h>

const int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
inline bool is_leap(int y) { return y % 4 == 0 && y % 100 != 0 || y % 400 == 0; }
bool is_valid(int y, int m, int d) {
    if (y < 1000 || m < 1 || m > 12 || d < 1) {
        return false;
    }
    int max_days = days[m];
    if (m == 2 && is_leap(y)) {
        max_days = 29;
    }
    return d <= max_days;
}

std::vector<int> pali_dates;
std::vector<int> abab_dates;

void pre_pali() {
    for (int y = 1000; y <= 9220; y++) {
        std::string s_y = std::to_string(y);
        std::string s_m_d = s_y;
        std::reverse(s_m_d.begin(), s_m_d.end());

        int m = std::stoi(s_m_d.substr(0, 2));
        int d = std::stoi(s_m_d.substr(2, 2));

        if (is_valid(y, m, d)) {
            pali_dates.push_back(std::stoi(s_y + s_m_d));
        }
    }
}

void pre_abab() {
    for (int a = 1; a <= 9; ++a) {
        for (int b = 0; b <= 9; ++b) {
            if (a == b) continue;

            int y = a * 1000 + b * 100 + a * 10 + b;
            int m = b * 10 + a;
            int d = m;

            if (is_valid(y, m, d)) {
                abab_dates.push_back(y * 10000 + m * 100 + d);
            }
        }
    }
}

int main() {
    // 预计算可能的日期
    pre_abab(); pre_pali();

    int n; std::cin >> n;
    
    // 用cpp内置方法二分搜索
    auto it_p = std::upper_bound(pali_dates.begin(), pali_dates.end(), n);
    auto it_a = std::upper_bound(abab_dates.begin(), abab_dates.end(), n);
    std::cout << *it_p << '\n' << *it_a << std::endl;

    return 0;
}

```
---
title: 【打卡】第八天
weight: 8
date: 2025-12-05T16:06:00+08:00
---

## P8752 [蓝桥杯 2021 省 B2] 特殊年份
> [点击此处跳转](https://www.luogu.com.cn/problem/P8752)

> [!NOTE] 考点
> 模拟

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-05 17:50:23
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int ans = 0;
    string s;
    for (int i = 0; i < 5; i++) {
        cin >> s;
        ans += s[0] == s[2] && s[1] + 1 == s[3];
    }
    cout << ans << endl;
}
```
## P8703 [蓝桥杯 2019 国 B] 最优包含
> [点击此处跳转](https://www.luogu.com.cn/problem/P8703)

> [!NOTE] 考点
> DP

这道题是一个非常经典的动态规划问题，稍作转换就会发现它的本质。

### 问题转换

我们的目标是**最少修改** `S` 中的字符，使 `S` 包含 `T` 作为子序列。

*   一个子序列是通过从 `S` 中“挑选”字符（不改变相对顺序）来形成的。
*   “修改” `S` 中的一个字符 `S[i]`，意味着我们可以把它变成任何我们想要的字符。

“最少修改”是一个优化问题，通常可以反过来思考：**如何最多地利用 `S` 中已有的字符？**

假设我们最终在 `S` 中找到了一个子序列，它与 `T` 完全匹配。这个子序列中的每个字符 `T[j]`，都对应 `S` 中的某个字符 `S[i]`。这个 `S[i]` 有两种可能来源：
1.  它**原本就等于** `T[j]` (`S[i] == T[j]`)。这是一个**未被修改**的、成功匹配的字符。
2.  它**原本不等于** `T[j]`，但我们把它**修改**成了 `T[j]`。

我们的目标是让第二种情况（修改）尽可能少。这意味着，我们应该让第一种情况（不修改）尽可能多。

我们要做的，就是在 `S` 中找到一个子序列，它也同时是 `T` 的子序列，并且这个子序列要尽可能地**长**。这个“最长的、同时是两者子序列”的东西，正是**最长公共子序列 (Longest Common Subsequence, LCS)** 的定义。

**结论**：
*   我们能找到的 `S` 和 `T` 之间的最长公共子序列的长度，`len(LCS(S, T))`，就代表了我们最多可以**保留（不修改）** 的字符数量。
*   `T` 总共需要 `len(T)` 个字符。
*   因此，我们必须通过**修改**来“创造”的字符数量就是 `len(T) - len(LCS(S, T))`。

问题被成功转换为：**求 `S` 和 `T` 的最长公共子序列，然后用 `T` 的长度减去它。**

### 动态规划求解LCS

LCS是一个经典的DP问题。

1.  **状态定义**:
    `dp[i][j]` 表示字符串 `S` 的前 `i` 个字符 (`S[1...i]`) 与字符串 `T` 的前 `j` 个字符 (`T[1...j]`) 的最长公共子序列的长度。

2.  **状态转移方程**:
    *   **如果 `S[i] == T[j]`**:
        这两个字符相同，它们可以共同构成LCS的一部分。所以，LCS的长度等于 `S` 的前 `i-1` 个字符和 `T` 的前 `j-1` 个字符的LCS长度再加一。
        `dp[i][j] = dp[i-1][j-1] + 1`
    *   **如果 `S[i] != T[j]`**:
        这两个字符不同，它们不能同时作为LCS的结尾。我们只能退而求其次，看看是“不考虑`S[i]`”还是“不考虑`T[j]`”能得到更长的LCS。
        `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

3.  **基本情况**:
    `dp[0][j] = 0` 且 `dp[i][0] = 0`。即任何字符串与空字符串的LCS长度都为0。


> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:28:57
 @Mail:        apollomonasa@gmail.com
 @Description: Codeforces template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int18;
using u128 = __uint128_t;
using namespace std;

void slv(){
    string s, t;
    cin >> s >> t;

    int n = s.length();
    int m = t.length();

    // 为了方便处理边界，可以在字符串前加一个占位符，使用1-based索引
    s = " " + s;
    t = " " + t;

    // dp[i][j] 表示 s 的前 i 个字符和 t 的前 j 个字符的 LCS 长度
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s[i] == t[j]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    int lcs_length = dp[n][m];
    int modifications = m - lcs_length;

    cout << modifications << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    slv();
    return 0;
}
```
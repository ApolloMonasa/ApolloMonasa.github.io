---
title: 【打卡】第十三天
weight: 13
date: 2025-12-10T16:06:00+08:00
---



# P13871 [蓝桥杯 2024 省 Java/Python A] 吊坠
> [点击此处跳转](https://www.luogu.com.cn/problem/P13871)
## 题目描述

小蓝想制作一个吊坠，他手上有 $n$ 个长度为 $m$ 的首尾相连的环形字符串 $\{s_1, s_2, \cdots, s_n\}$，他想用 $n-1$ 条边将这 $n$ 个字符串连接起来做成吊坠，要求所有的字符串连完后形成一个整体。连接两个字符串 $s_i, s_j$ 的边的边权为这两个字符串的最长公共子串的长度（可以按环形旋转改变起始位置，但不能翻转），小蓝希望连完后的这 $n-1$ 条边的边权和最大，这样的吊坠他觉得最好看，请计算最大的边权和是多少。

> [!NOTE] 考点
> **最大生成树 (Maximum Spanning Tree)**、**动态规划 (LCS)**、**字符串处理**
>
> 1.  **问题转化**：题目要求用 $n-1$ 条边连接 $n$ 个节点，且边权和最大，这显然是一个**最大生成树**问题。我们需要先构建一个完全图，计算任意两个字符串之间的权值，然后跑 Prim 或 Kruskal 算法。
> 2.  **权值计算**：两个环形字符串 $s_i, s_j$ 的最长公共子串。
>       * 由于是环形，我们可以将 $s_i$ 复制一份拼接成 $ss_i = s_i + s_i$（长度为 $2m$）。
>       * 问题转化为：求 $ss_i$ 和 $s_j$ 的最长公共子串，且长度不能超过 $m$。
>       * 由于 $m$ 很小 ($m \le 50$)，我们可以直接枚举或者使用简单的动态规划来求解最长公共子串。
>       * $DP[x][y]$ 表示以 $ss_i[x]$ 和 $s_j[y]$ 结尾的最长公共子串长度。
> 3.  **复杂度分析**：
>       * 计算任意两点权值：$O(n^2 \cdot m^2)$。代入数据 $200^2 \times 50^2 \approx 10^8$，在 C++ 中是可以接受的。
>       * 最大生成树：$O(n^2)$ 或 $O(n^2 \log n)$。
>       * 整体复杂度满足要求。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// DSU 用于 Kruskal 算法
struct DSU {
    vector<int> parent;
    DSU(int n) {
        parent.resize(n + 1);
        iota(parent.begin(), parent.end(), 0);
    }
    int find(int x) {
        if (x == parent[x]) return x;
        return parent[x] = find(parent[x]);
    }
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
            return true;
        }
        return false;
    }
};

struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight > other.weight; // 最大生成树，按权值降序
    }
};

// 计算两个字符串（其中 s1 视为环形）的最长公共子串
int get_cyclic_lcs(string s1, string s2, int m) {
    string ss1 = s1 + s1;
    int len1 = ss1.length();
    int len2 = s2.length();
    int max_len = 0;
    
    // dp[j] 表示以 s2[j-1] 结尾的匹配长度，空间优化为一维数组
    // 这里为了稳妥直接用二维逻辑思考，m很小可以用暴力枚举
    for (int i = 0; i < len1; i++) {
        for (int j = 0; j < len2; j++) {
            int current_len = 0;
            int x = i, y = j;
            while (x < len1 && y < len2 && ss1[x] == s2[y]) {
                current_len++;
                x++;
                y++;
            }
            // 环形匹配长度不能超过原长 m
            max_len = max(max_len, min(current_len, m));
        }
    }
    return max_len;
}

void solve() {
    int n, m;
    if (!(cin >> n >> m)) return;
    
    vector<string> s(n);
    for(int i=0; i<n; i++) cin >> s[i];
    
    vector<Edge> edges;
    // 计算所有对的边权
    for(int i=0; i<n; i++) {
        for(int j=i+1; j<n; j++) {
            int w = 0;
            // 因为不能翻转，但可以旋转，所以要双向比较或者只比较单向？
            // 题目说“连接两个字符串...的边权”，通常是无向的。
            // 无论谁旋转，相对顺序不变。所以 calc(s1, s2) 应该等于 calc(s2, s1)
            // 实际上 s1+s1 和 s2 比较即可涵盖所有旋转情况
            w = max(get_cyclic_lcs(s[i], s[j], m), get_cyclic_lcs(s[j], s[i], m));
            edges.push_back({i, j, w});
        }
    }
    
    sort(edges.begin(), edges.end());
    
    DSU dsu(n);
    int edges_count = 0;
    ll total_weight = 0;
    
    for(auto& e : edges) {
        if(dsu.unite(e.u, e.v)) {
            total_weight += e.weight;
            edges_count++;
            if(edges_count == n - 1) break;
        }
    }
    
    cout << total_weight << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```

-----

# P12893 [蓝桥杯 2025 国 Java B] 隔离网络
> [点击此处跳转](https://www.luogu.com.cn/problem/P12893)
## 题目描述

小蓝负责一家科技公司的数据中心安全。该数据中心包含 $N$ 台服务器和 $M$ 条数据链路。
每轮操作：

1.  确定所有连通的服务器集群。
2.  对于每个集群，禁用该集群内**编号最小**的那条链路。
    重复直到所有链路被禁用。求总操作次数。

> [!NOTE] 考点
> **逆向思维**、**并查集 (DSU)**、**树高计算**
>
> 1.  **正向模拟的困难**：正向模拟每一轮删除最小边，需要不断寻找连通分量和最小值，复杂度较高，容易超时。
> 2.  **逆向思考**：我们可以考虑边是**从大到小加入**的。
>       * 假设我们有一个空的图，我们将边按照编号**从大到小 ($M \to 1$)** 依次加入。
>       * 对于一条边 $e = (u, v)$，它的编号比当前图中所有边的编号都要小。
>       * 如果在正向过程中，我们删除了 $e$，那么：
>           * 如果 $e$ 是**桥 (Bridge)**：删除 $e$ 后，原来的连通分量会分裂成两个。这意味着在逆向过程中，加入 $e$ 会连接两个原本独立的连通分量。此时，处理完合并后的分量所需的时间 = $1 + \max(\text{左分量时间}, \text{右分量时间})$。
>           * 如果 $e$ **不是桥**（在环上）：删除 $e$ 后，连通分量依然连通。这意味着在逆向过程中，加入 $e$ 连接的是同一个连通分量的两个节点。此时，处理完这个分量所需的时间 = $1 + \text{原分量时间}$。
> 3.  **算法流程**：
>       * 初始化并查集，维护每个集合的一个属性 `dp`，表示消除该集合内所有边所需的操作次数。初始全为 0。
>       * 从 $M$ 到 $1$ 逆序遍历每一条边 $(u, v)$。
>       * 查找 $u, v$ 的根节点 $rootU, rootV$。
>       * 如果 $rootU \neq rootV$（连接两个分量）：`new_dp = max(dp[rootU], dp[rootV]) + 1`，合并集合。
>       * 如果 $rootU == rootV$（形成环）：`new_dp = dp[rootU] + 1`，更新集合属性。
>       * 最终答案是所有连通分量 `dp` 值的最大值。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

struct Edge {
    int u, v, id;
};

// 带有 DP 状态维护的并查集
struct DSU {
    vector<int> parent;
    vector<int> dp; // dp[i] 表示清除以 i 为根的集合所需的操作次数
    
    DSU(int n) {
        parent.resize(n + 1);
        iota(parent.begin(), parent.end(), 0);
        dp.assign(n + 1, 0);
    }
    
    int find(int x) {
        if (x == parent[x]) return x;
        return parent[x] = find(parent[x]);
    }
    
    // 处理一条边 (u, v)，这是当前集合中编号最小的边（因为逆序处理）
    void process_edge(int u, int v) {
        int rootU = find(u);
        int rootV = find(v);
        
        if (rootU != rootV) {
            // 连接两个不同的连通块 -> 正向看是删除了一个桥，分裂成两块
            // 逆向看：合并两块，当前边是这个新集合中最小的边
            // 需要的回合数 = 1 (当前边) + max(两边子问题的时间)
            int new_val = max(dp[rootU], dp[rootV]) + 1;
            parent[rootU] = rootV;
            dp[rootV] = new_val;
        } else {
            // 连接同一个连通块 -> 正向看是删除了环上的一条边，集合未分裂
            // 逆向看：当前边是集合中最小的边
            // 需要的回合数 = 1 (当前边) + 剩余部分的时间
            dp[rootU]++;
        }
    }
};

void solve() {
    int n, m;
    if (!(cin >> n >> m)) return;
    
    vector<Edge> edges(m + 1);
    for (int i = 1; i <= m; i++) {
        cin >> edges[i].u >> edges[i].v;
        edges[i].id = i;
    }
    
    DSU dsu(n);
    
    // 逆向处理：从编号最大的边 M 开始直到 1
    for (int i = m; i >= 1; i--) {
        dsu.process_edge(edges[i].u, edges[i].v);
    }
    
    // 答案是所有连通块中需要的最大操作次数
    int max_ops = 0;
    for (int i = 1; i <= n; i++) {
        if (dsu.parent[i] == i) {
            max_ops = max(max_ops, dsu.dp[i]);
        }
    }
    
    cout << max_ops << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```
---
title: 【打卡】第十一天
weight: 11
date: 2025-12-08T16:06:00+08:00
---

## P12342 [蓝桥杯 2025 省 B/Python B 第二场] 数列差分

> [点击此处跳转](https://www.luogu.com.cn/problem/P12342)

> [!NOTE] 考点
> **贪心算法**、**排序**、**双指针**
>
> 1.  **重排特性**：由于可以任意重排 $B$ 数列，这意味着 $B$ 中元素的初始顺序不重要，重要的是数值本身。
> 2.  **贪心策略**：为了让 $A-B$ 的结果全为正整数，即对于每一对 $(a_i, b_i)$ 都要满足 $a_i > b_i$。我们希望尽可能多地保留 $B$ 中原本的数，只修改无法匹配的数。
> 3.  **最优匹配**：
>       * 将 $A$ 和 $B$ 分别从小到大排序。
>       * 对于当前 $A$ 中最小的元素 $a_i$，我们应该尝试用 $B$ 中能满足条件（$b_j < a_i$）的最小元素 $b_j$ 去匹配它。
>       * **为什么选最小的 $b_j$？** 因为如果最小的 $b_j$ 都能满足 $a_i$，那么它留给后面更大的 $a$ 可能会造成“大材小用”；而如果最小的 $b_j$ 都不能满足 $a_i$，那么更大的 $b$ 肯定也不能满足，此时 $a_i$ 注定无法通过现有的 $B$ 匹配（需要修改操作）。
> 4.  **算法流程**：使用双指针遍历排序后的数组。如果 $b_j < a_i$，则匹配成功（count++），指针同时后移；否则说明 $b_j$ 太大，无法匹配当前的 $a_i$，但可能匹配后面更大的 $a$，因此只移动 $A$ 的指针，保留 $B$ 的当前元素。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

void solve() {
    int n;
    if (!(cin >> n)) return;

    vector<int> a(n), b(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];

    // 贪心策略：排序后尝试用最小的 b 去满足最小的 a
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());

    int match_count = 0;
    int j = 0; // 指向 b 的指针

    for (int i = 0; i < n; i++) {
        // 在 b 中寻找第一个小于 a[i] 的元素
        // 由于已经排序，只需检查当前的 b[j]
        if (j < n && b[j] < a[i]) {
            // 匹配成功：这个 b[j] 可以作为 a[i] 的减数
            match_count++;
            j++; // b[j] 已被使用，移向下一个
        }
        // 如果 b[j] >= a[i]，说明当前的 b[j] 太大了，不能满足 a[i]。
        // 但 b[j] 可能满足后面更大的 a，所以我们跳过当前的 a[i] (视为需要修改操作)，
        // 保留 b[j] 给后面的机会。
    }

    // 总数 - 不需要修改就能匹配的数量 = 最少修改次数
    cout << n - match_count << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```

-----

## P12838 [蓝桥杯 2025 国 B] 子串去重

> [点击此处跳转](https://www.luogu.com.cn/problem/P12838)

> [!NOTE] 考点
> **序列自动机思想（预处理下一位置）**、**字符集特性**、**模拟**
>
> 1.  **问题转化**：题目要求对子串去重，去重规则是“保留每种字符第一次出现的位置”。这意味着生成的去重字符串长度最多只有 26（字符集 'a'-'z'）。
> 2.  **性能瓶颈**：如果每次询问都遍历子串 $S[L \dots R]$ 来提取字符，最坏情况下复杂度是 $O(N \cdot M)$，会超时。我们需要快速找到区间 $[L, R]$ 内字符 'a', 'b', ..., 'z' 第一次出现的位置。
> 3.  **预处理优化**：
>       * 定义 `nxt[i][char]` 表示在字符串 $S$ 中，位置 $i$ 及之后，字符 `char` 第一次出现的索引。
>       * 我们可以倒序遍历字符串 $S$ 来计算这个二维数组。
>       * 对于每次询问 $(L, R)$，我们只需遍历 26 个字母，检查 `pos = nxt[L][c]` 是否小于等于 $R$。如果是，说明该字符存在于子串中，且第一次出现位置为 `pos`。
> 4.  **构建结果**：将找到的所有 `(pos, char)` 对按照 `pos` 排序，提取出的 `char` 序列就是去重后的子串。
> 5.  **比较**：直接比较两个生成的短字符串（长度 $\le 26$），统计不同位置的个数。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// nxt[i][j] 表示在索引 i (包含) 之后，字符 j ('a'+j) 第一次出现的位置
// 大小开到 100005，字符集 26
int nxt[100005][26];

// 辅助函数：获取去重后的子串
string get_unique_substr(int L, int R) {
    // 存储 (位置, 字符) 对
    vector<pair<int, char>> chars;
    
    // 遍历 26 个字母
    for (int c = 0; c < 26; c++) {
        int pos = nxt[L][c];
        // 如果该字符在区间 [L, R] 内存在
        if (pos <= R) {
            chars.push_back({pos, (char)('a' + c)});
        }
    }
    
    // 按照出现位置排序，还原出原本的出现顺序
    sort(chars.begin(), chars.end());
    
    string res = "";
    for (auto p : chars) {
        res += p.second;
    }
    return res;
}

void solve() {
    string s;
    if (!(cin >> s)) return;
    int n = s.length();
    
    // 预处理 nxt 数组
    // 初始化最后一位的下一位为无穷大 (n + 1)
    for (int c = 0; c < 26; c++) {
        nxt[n + 1][c] = n + 1;
    }
    
    // 倒序填充
    // 题目输入下标通常是 1-based，我们为了方便配合输入，这里处理成 1-based 索引
    // s 的下标是 0 到 n-1，对应逻辑下标 1 到 n
    for (int i = n; i >= 1; i--) {
        int char_idx = s[i - 1] - 'a';
        for (int c = 0; c < 26; c++) {
            if (c == char_idx) {
                nxt[i][c] = i; // 当前位置就是该字符
            } else {
                nxt[i][c] = nxt[i + 1][c]; // 继承后面的位置
            }
        }
    }

    int m;
    cin >> m;
    while (m--) {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        
        // 利用预处理数组快速生成去重字符串 (长度 <= 26)
        string s1 = get_unique_substr(l1, r1);
        string s2 = get_unique_substr(l2, r2);
        
        // 比较差异
        int diff = 0;
        int len1 = s1.length();
        int len2 = s2.length();
        int max_len = max(len1, len2);
        
        for (int i = 0; i < max_len; i++) {
            // 如果某一位超出长度，或者字符不同，则差异+1
            if (i >= len1 || i >= len2 || s1[i] != s2[i]) {
                diff++;
            }
        }
        cout << diff << "\n";
    }
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```
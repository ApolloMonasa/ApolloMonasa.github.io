---
title: 【打卡】第四天
weight: 4
date: 2025-12-01T16:06:00+08:00
---

## P8780 [蓝桥杯 2022 省 B] 刷题统计
> [点击此处跳转](https://www.luogu.com.cn/problem/P8780)

> [!NOTE] 考点
> 简单模拟

我们采用的策略是先除每周能做的题数锁定周数，最后零散的天数直接暴力模拟，这样的好处是既不容易`爆ll`，而且代码量还少。

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-01 15:15:02
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    ll a, b, n; std::cin >> a >> b >> n;
    ll ans = 0, week_num = a * 5 + b * 2;
    ans += n / week_num * 7;
    n %= week_num;
    int d = 0;
    while (n > 0) {
        d++;
        if (d <= 5) n -= a;
        else n -= b;
    }
    ans += d;
    std::cout << ans << '\n';
}
```
## P8795 [蓝桥杯 2022 国 A] 选素数
> [点击此处跳转](https://www.luogu.com.cn/problem/P8795)

> [!NOTE] 考点
> 数论


### **1. 问题解构**

首先，我们对题目中定义的操作进行形式化。
令操作为 `op(x, p)`，其中 `x` 是当前数，`p` 是一个小于 `x` 的素数。
操作结果 `x'` 定义为：大于等于 `x` 的最小的 `p` 的倍数。
这可以表示为：
`x' = x`  (如果 `x % p == 0`)
`x' = x + (p - (x % p))` (如果 `x % p != 0`)
一个等价的数学表达是 `x' = ⌈x / p⌉ * p`。

题目给定最终结果 `n`，它是由某个初始值 `x₀` 经过两次操作得到的：
`x₁ = op(x₀, p₁)`
`n = op(x₁, p₂)`

其中 `p₁` 是素数且 `p₁ < x₀`，`p₂` 是素数且 `p₂ < x₁`。
我们的目标是找到满足这些条件的最小的 `x₀`。

### **2. 核心策略：逆向推导**

由于唯一给定的值是最终结果 `n`，最自然的求解路径是从 `n` 开始，逆向推导出所有可能的中间值 `x₁`，再从每个合法的 `x₁` 逆向推导出其所能对应的最小 `x₀`，最终在所有可能的 `x₀` 中取最小值。

### **3. 从 `n` 到 `x₁` 的约束分析**

根据操作 `n = op(x₁, p₂)`，我们可以推断出 `n`, `x₁`, `p₂` 之间必须满足的关系：

1.  **`n` 必须是 `p₂` 的倍数**：这是操作定义的直接结果。
2.  **`x₁` 的范围**：`n` 是大于等于 `x₁` 的**最小** `p₂` 倍数。这意味着 `x₁` 必须大于 `n` 的前一个 `p₂` 倍数，即 `n - p₂`。因此，`x₁` 必须位于区间 `(n - p₂, n]` 内。
3.  **`p₂` 的约束**：题目要求 `p₂ < x₁`。结合 `x₁` 的范围，`p₂` 必须小于 `x₁` 的所有可能值。由于 `x₁` 可以任意接近其下界 `n - p₂`，故 `p₂` 必须满足 `p₂ > n - x₁`。

综上，一个数 `x₁` 是一个合法的中间值，当且仅当存在一个素数 `p₂` 同时满足以下三个条件：
- `n % p₂ == 0`
- `p₂ < x₁`
- `p₂ > n - x₁`

### **4. 从 `x₁` 到 `x₀` 的约束分析**

同理，对于操作 `x₁ = op(x₀, p₁)`：

1.  **`x₁` 必须是 `p₁` 的倍数**。由于 `x₀` 经过一次操作变为 `x₁`，`x₁` 自身必须是某个素数 `p₁` 的倍数。这意味着 `x₁` 必须是一个**合数**（或至少是一个素数的倍数，但若 `x₁` 是素数，则 `p₁` 不存在）。
2.  **`x₀` 的范围**：`x₀` 位于区间 `(x₁ - p₁, x₁]` 内。
3.  **`p₁` 的约束**：`p₁ < x₀`。

结合 `x₀` 的范围和 `p₁` 的约束，我们得到 `x₀` 必须同时大于 `x₁ - p₁` 和 `p₁`。因此，对于一个给定的 `x₁` 和一个选定的质因数 `p₁`，`x₀` 的最小整数值为 `max(p₁, x₁ - p₁) + 1`。

### **5. 核心引理：`x₀` 的最小化**

**引理**：对于给定的合数 `x₁`，为使其对应的 `x₀` 最小，即最小化表达式 `f(p) = max(p, x₁ - p) + 1`，最优选择是令 `p` 为 `x₁` 的**最大质因数 (Largest Prime Factor, LPF)**。

**证明**:
由于 `+1` 是常数项，我们只需最小化 `g(p) = max(p, x₁ - p)`，其中 `p` 是 `x₁` 的一个质因数。

1.  **关键性质**：对于任意合数 `x₁`，其任意质因数 `p` 必满足 `p ≤ x₁ / 2`。
    *   **证明**：设 `x₁ = p * k`。因 `x₁` 是合数，`k` 必为大于1的整数，故 `k ≥ 2`。因此 `x₁ = p * k ≥ p * 2`，可得 `p ≤ x₁ / 2`。

2.  **函数简化**：根据上述性质 `p ≤ x₁ / 2`，我们可以推断 `x₁ - p ≥ x₁ - x₁ / 2 = x₁ / 2`。因此，在 `p` 和 `x₁ - p` 中，`x₁ - p` 总是较大（或相等）的一方。
    故 `g(p) = max(p, x₁ - p)` 在定义域（`x₁` 的质因数集合）上可简化为 `g(p) = x₁ - p`。

3.  **得出结论**：为了最小化 `g(p) = x₁ - p`，我们必须最大化 `p`。在 `x₁` 的所有质因数中，最大的 `p` 即为 `x₁` 的最大质因数。

**引理证毕**。

因此，对于一个合法的 `x₁`，其对应的最小 `x₀` 为 `max(lpf(x₁), x₁ - lpf(x₁)) + 1`。

### **6. 算法综合与实现**

基于以上分析，我们可以构建如下算法：

1.  **预处理**：使用线性筛法在 `O(N)` 时间内计算出 `[2, n]` 范围内所有整数的**最小质因数 (Smallest Prime Factor, SPF)**，并得到素数列表。`N` 为 `10^6`。
2.  **分解 `n`**：利用预处理的 `spf` 数组，在 `O(log n)` 时间内分解 `n`，获得其所有唯一的质因数，存入 `n_prime_factors`。
3.  **初始化**：设 `min_x₀ = -1` (表示无解)。
4.  **主循环**：遍历所有可能的中间值 `x₁`，从 `4` 到 `n`（`x₁` 必须是合数）。
    a. **合法性检验**：对于每个 `x₁`，检查其是否为合数 (`spf[x₁] != x₁`)。若是，则遍历 `n_prime_factors` 中的 `p₂`，判断是否存在一个 `p₂` 满足 `n - x₁ < p₂ < x₁`。若存在，则 `x₁` 是一个合法的中间值。
    b. **计算最小 `x₀`**：若 `x₁` 合法，则计算其最大质因数 `p₁ = lpf(x₁)`。这可以通过 `spf` 数组在 `O(log x₁)` 时间内完成。
    c. 根据引理，计算此 `x₁` 对应的最小 `x₀`：`current_x₀ = max(p₁, x₁ - p₁) + 1`。
    d. **更新全局最优解**：`min_x₀ = min(min_x₀, current_x₀)` (若 `min_x₀` 为 -1 则直接赋值)。
5.  **输出**：循环结束后，输出 `min_x₀`。

**复杂度分析**:
- 筛法预处理: `O(N)`
- 主循环: `O(N)`
- 循环内部: `x₁` 的合法性检查耗时 `O(d(n))` (d(n)为n的质因数个数，远小于 `log n`)；`lpf(x₁)` 的计算耗时 `O(log x₁)`。
- **总时间复杂度**: `O(N * log N)`，对于 `N = 10^6` 而言完全可以通过。



> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:28:57
 @Mail:        apollomonasa@gmail.com
 @Description: Codeforces template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// spf 数组 (Smallest Prime Factor)，存储每个数的最小质因子
vector<int> spf; 
// primes 向量，存储所有在[2, n]范围内的素数
vector<int> primes;

// 线性筛法，用于在O(N)时间内预处理出[2, n]范围内所有数的最小质因子
void sieve(int n) {
    spf.resize(n + 1);
    for (int i = 2; i <= n; ++i) {
        // 如果spf[i]为0，说明i没有被更小的数筛过，因此i是一个素数
        if (spf[i] == 0) {
            spf[i] = i; // 素数的最小质因子是它本身
            primes.push_back(i);
        }
        // 遍历已找到的素数，用来筛掉合数
        for (int p : primes) {
            // 核心优化：如果p已经大于i的最小质因子，或者i*p超出了范围，就停止
            // 这保证了每个合数只会被它的最小质因子筛掉一次
            if (p > spf[i] || (ll)i * p > n) {
                break;
            }
            // p 是 i*p 的最小质因子
            spf[i * p] = p;
        }
    }
}

// 辅助函数：利用预处理好的spf数组，高效地求解任何数num的最大质因数(LPF)
int get_lpf(int num) {
    int lpf = 0; // lpf (Largest Prime Factor)
    // 循环直到num被分解为1
    while (num > 1) {
        // 更新我们见过的最大质因子
        lpf = max(lpf, spf[num]);
        // 从num中剔除掉它的最小质因子，继续分解
        num /= spf[num];
    }
    return lpf;
}

void slv(){
    int n;
    cin >> n;

    // 步骤1: 预处理，计算出到n为止所有数的最小质因子
    sieve(n);

    // 步骤2: 提前分解n，获取n的所有质因数，以加速后续检查
    vector<int> n_prime_factors;
    int temp_n = n;
    while (temp_n > 1) {
        int p = spf[temp_n];
        n_prime_factors.push_back(p);
        // 跳过所有相同的质因子
        while (temp_n % p == 0) temp_n /= p;
    }
    
    // 初始化最小的初始值x0为-1（表示无解）
    ll min_x0 = -1;

    // 步骤3: 遍历所有可能的中间值x1
    // x1是经过一次操作得到的，所以它必须是合数，最小满足要求的合数是4
    for (int x1 = 4; x1 <= n; ++x1) {
        // 如果spf[x1] == x1，说明x1是素数，跳过
        if (spf[x1] == x1) continue;

        // 步骤4: 检查x1是否是一个合法的中间值
        // 合法意味着存在一个素数p2，使得x1经过op(x1, p2)后能得到n
        // 这等价于：n是p2的倍数，且 x1 落在 (n-p2, n] 区间内
        bool is_valid_x1 = false;
        for (int p2 : n_prime_factors) {
            // 同时需要满足p2 < x1的约束
            if (p2 < x1 && p2 > n - x1) {
                is_valid_x1 = true;
                break; // 找到一个即可
            }
        }
        
        // 如果x1是合法的
        if (is_valid_x1) {
            // 步骤5: 计算由x1能推导出的最小x0
            // 根据证明，应选择x1的最大质因数p1来最小化x0
            int p1 = get_lpf(x1);
            
            // p1必须是x1的真因子，所以p1 < x1
            if (p1 >= x1) continue;

            // 初始x0的推导：
            // 约束1: x0 > x1 - p1  =>  x0 >= x1 - p1 + 1
            // 约束2: x0 > p1        =>  x0 >= p1 + 1
            // 两者取最大值，即为最小的合法x0
            // 下面的代码实现了 min_x0 = max(x1-p1+1, p1+1)
            
            // 先按约束1计算一个候选值
            ll current_x0 = (ll)x1 - p1 + 1;
            
            // 再用约束2进行修正
            if(p1 >= current_x0) {
               current_x0 = p1 + 1;
            }

            // 更新全局最小的x0
            if (min_x0 == -1 || current_x0 < min_x0) {
                min_x0 = current_x0;
            }
        }
    }

    // 输出最终结果
    cout << min_x0 << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    slv();
    return 0;
}


```
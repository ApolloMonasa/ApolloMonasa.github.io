---
title: 【打卡】第十四天
weight: 14
date: 2025-12-11T16:06:00+08:00
---


# P13874 [蓝桥杯 2024 省 Java/Python A] 最大异或结点
> [点击此处跳转](https://www.luogu.com.cn/problem/P13874)

## 题目描述

小蓝有一棵树，树中包含 $N$ 个结点，每个结点上都有一个整数 $X_i$。他可以从树中任意选择两个**不直接相连**的结点 $a$、$b$ 并获得分数 $X_a \oplus X_b$。请问小蓝可以获得的最大分数是多少？

> [!NOTE] 考点
> **01 Trie（字典树）**、**树上启发式合并 (DSU on Tree)**、**贪心**
>
> 1.  **问题转化**：
>     题目要求找到一对 $(u, v)$，满足 $u, v$ 不相邻（无直接边相连），使得 $X_u \oplus X_v$ 最大。
>     如果我们忽略“不直接相连”这个条件，那就是经典的“在一个集合中找两个数使得异或和最大”的问题，通常使用 **01 Trie** 解决。
>     加上限制条件后，我们依然可以借助 01 Trie。对于当前结点 $u$，我们希望在整棵树中找到一个结点 $v$，使得 $X_u \oplus X_v$ 最大，且 $v$ 不是 $u$ 的邻居（父节点或子节点）。
>
> 2.  **解题思路**：
>
>       * **全局最大异或对**：首先，我们可以不管限制条件，直接将所有 $X_i$ 插入 01 Trie，求出全局的最大异或值。设最大值由 $(u, v)$ 贡献。
>       * **处理限制**：
>           * 如果 $(u, v)$ 不相邻，那么答案就是这个全局最大值。
>           * 如果 $(u, v)$ 相邻，我们需要寻找次优解，或者更换思路。
>
> 3.  **更通用的做法 (枚举 + 删除)**：
>
>       * 我们可以将所有节点的值插入 01 Trie。
>       * 枚举每一个节点 $u$ 作为异或对的一端。
>       * 在 Trie 中查询与 $X_u$ 异或最大的值。
>       * **关键点**：由于 $u$ 不能与它的直接邻居（父节点 $fa[u]$ 和所有子节点 $child[u]$）匹配。
>       * 查询时，我们先暂时从 Trie 中**删除** $u$ 的所有邻居的值（以及 $u$ 自己）。
>       * 然后在 Trie 中查询与 $X_u$ 的最大异或值。
>       * 查询完后，再将刚才删除的邻居值**恢复**回去。
>       * 这样对每个节点做一次，取最大值即可。
>
> 4.  **复杂度分析**：
>
>       * 插入所有点：$O(N \log V)$。
>       * 对于每个点 $u$，删除邻居 -\> 查询 -\> 恢复邻居。总的删除/恢复次数等于边的数量乘 2（每条边被两端各访问一次），即 $O(N \log V)$。
>       * 总复杂度 $O(N \log V)$，其中 $V$ 是数值范围（31位）。这是可以通过的。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 01 Trie 实现
const int MAX_BITS = 31;
// 节点池大小：N * 31，大致 3e6
const int MAX_NODES = 100005 * 32;

struct Trie {
    int son[MAX_NODES][2];
    int cnt[MAX_NODES]; // 记录该节点被经过的次数，用于“删除”操作
    int idx;

    Trie() {
        idx = 0;
        memset(son, 0, sizeof(son));
        memset(cnt, 0, sizeof(cnt));
    }

    // 插入或删除 val (v=1 插入, v=-1 删除)
    void update(int val, int v) {
        int u = 0;
        for (int i = MAX_BITS; i >= 0; i--) {
            int bit = (val >> i) & 1;
            if (!son[u][bit]) son[u][bit] = ++idx;
            u = son[u][bit];
            cnt[u] += v;
        }
    }

    // 查询与 val 异或最大的值
    int query(int val) {
        int u = 0;
        int res = 0;
        for (int i = MAX_BITS; i >= 0; i--) {
            int bit = (val >> i) & 1;
            // 贪心：尽量走相反的位
            // 必须保证目标节点存在且 cnt > 0 (未被删除)
            if (son[u][!bit] && cnt[son[u][!bit]] > 0) {
                res |= (1 << i);
                u = son[u][!bit];
            } else {
                // 没法走相反的，只能走相同的（如果相同的也被删完了，那就有问题了，
                // 但题目保证 N>=2 且只要删掉邻居后还有剩余节点即可）
                // 实际上根据题目逻辑，树中至少有2个点，即使删掉所有邻居，
                // 只要不是菊花图中心且N很小，通常能找到。
                // 如果整棵树都被删空了（不可能，因为只删邻居），则返回0
                if (son[u][bit] && cnt[son[u][bit]] > 0) {
                    u = son[u][bit];
                } else {
                    return 0; // Should not happen given constraints if checked properly
                }
            }
        }
        return res;
    }
} trie;

vector<int> adj[100005];
int val[100005];

void solve() {
    int n;
    if (!(cin >> n)) return;

    for (int i = 0; i < n; i++) cin >> val[i];

    // 读入父节点构建邻接表
    for (int i = 0; i < n; i++) {
        int f;
        cin >> f;
        if (f != -1) {
            adj[i].push_back(f);
            adj[f].push_back(i);
        }
    }

    // 1. 将所有数值插入 Trie
    for (int i = 0; i < n; i++) {
        trie.update(val[i], 1);
    }

    int max_xor = 0;

    // 2. 枚举每个点 u，尝试寻找最佳匹配
    for (int u = 0; u < n; u++) {
        // 临时删除 u 及其所有邻居
        trie.update(val[u], -1);
        for (int v : adj[u]) {
            trie.update(val[v], -1);
        }

        // 查询最大异或值
        // 注意：如果删除后 Trie 为空（例如 N=2，u和v互为邻居，都删了），
        // 此时无法形成不相邻对，query 结果可能无效，需要特判。
        // 但题目问最大分数，如果任意两点都相邻（只有一条边），那无法选择？
        // 题目说“从树中任意选择两个不直接相连的结点”，如果 N=2，确实选不出来。
        // 这种情况下答案应该是多少？通常题目数据 N 会保证有解，或者 N >= 3。
        // 代码里 query 如果路径不通会返回 0，需要根据实际情况。
        // 这里假设总能找到（除了 N=2 的情况）。
        
        // 我们利用 cnt[0] (根节点的子节点总数) 或者外部记录剩余节点数来判断
        // 其实很简单，只要 Trie 根节点的子节点 cnt 之和 > 0 就能查
        
        // 修正：query 内部如果走不动返回了 0，可能是真正的 0 也可能是没路了。
        // 最好是在 query 前判断一下剩余点数。
        
        // 统计删除了多少个点
        int removed_cnt = 1 + adj[u].size();
        if (n - removed_cnt > 0) {
             max_xor = max(max_xor, trie.query(val[u]));
        }

        // 恢复 u 及其所有邻居
        for (int v : adj[u]) {
            trie.update(val[v], 1);
        }
        trie.update(val[u], 1);
    }

    cout << max_xor << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```

-----

# P12834 [蓝桥杯 2025 国 B] 项链排列
> [点击此处跳转](https://www.luogu.com.cn/problem/P12834)
## 题目描述

小蓝有 $A$ 个 'L' 和 $B$ 个 'Q'。排列中美感定义为“相邻且不同字符对”的数量。求变化次数恰好为 $C$ 且**字典序最小**的排列。

> [!NOTE] 考点
> **构造算法**、**贪心**、**边界条件处理**
>
> 1.  **字典序最小原则**：
>     我们要让字符串前面的字符尽可能小。已知 'L' 的字典序小于 'Q'。
>     所以我们应**尽可能在前面放 'L'**，直到不得不放 'Q' 为止。
>
> 2.  **变化次数的本质**：
>     变化次数 $C$ 本质上就是字符串中“块”的数量减 1（或者是切换段的次数）。
>     例如 `LL...L QQ...Q LL...L` 这样的结构，发生了 2 次变化。
>
> 3.  **构造策略**：
>     我们逐位确定字符。假设当前剩余 $a$ 个 'L'，$b$ 个 'Q'，还需要凑够 $c$ 次变化，上一个字符是 `last_char`。
>     我们优先尝试放 'L'：
>
>       * 如果放 'L'：
>           * 如果 `last_char` 也是 'L'，变化次数不增加，剩余目标 $c$ 不变。
>           * 如果 `last_char` 是 'Q'，变化次数增加，剩余目标 $c-1$。
>       * **关键判定**：放了 'L' 之后，剩下的 $a-1$ 个 'L' 和 $b$ 个 'Q' **是否足够/能够** 凑出剩余的 $c$（或 $c-1$）次变化？
>           * 最大变化次数：给定 $x$ 个 A 和 $y$ 个 B，最大能产生的变化次数是 $2 \times \min(x, y)$ （如果 $x=y$ 则为 $2x-1$ 或 $2x$，取决于排列）。准确说是 $2 \times \min(x, y) + [x \ne y]$ 吗？其实就是穿插排列：`LQLQLQ...`。最大变化数是 $x+y-1$ 如果我们不限制位置，但在固定余量下，最大变化数是 $2 \times \min(x, y) + (x > y ? 0 : 0)$... 不太直观。
>           * 更简单的判定：如果有 $x$ 个 A 和 $y$ 个 B，能构造出的变化次数范围是 $[1, 2 \min(x, y) + (\text{若 } x \ne y \text{ 则 } 1 \text{ 否则 } 0)]$ 吗？
>           * 其实，只要 $c$ 不超过“剩余字符能产生的最大交替数”，并且 $c$ 至少需要保证如果某一种字符只剩 0 个时不能再要求变化，就可以。
>
> 4.  **Check 函数**：
>     `check(remA, remB, reqC, nextChar)`: 如果下一个放 `nextChar`，能否在后续完成任务？
>     假设放了 `nextChar` 后，还剩 $A'$ 个 L，$B'$ 个 Q，需要 $C'$ 次变化。
>     我们只需判断：$C' \le \text{MaxChanges}(A', B', \text{start}=nextChar)$。
>     以 $X$ 开头，拥有 $n_x$ 个 X 和 $n_y$ 个 Y，最大变化次数是多少？
>     形如 `X Y X Y X Y ...`。
>     如果是 `X Y X Y ...` (X多)，变化数 $2 \times n_y$。
>     如果是 `X Y X Y ...` (Y多)，变化数 $2 \times n_x$。
>     如果是 `X Y X Y` (一样多)，变化数 $2 \times n_x - 1$。
>     综上，最大变化数是：
>
>       * 若 $n_x > n_y$: $2 \times n_y$
>       * 若 $n_y > n_x$: $2 \times n_x$ (实际上是 $2 n_x + 1$? 不，以 X 开头，必须 X Y X...，Y 只能被夹在中间或结尾。Y 有 $n_y$ 个。X 有 $n_x$ 个。最多形成 $n_x$ 个 X 段。Y 可以填在 $n_x$ 个空位里。最多 $2 n_x$ 次变化)。
>         Wait, 简单推导：
>         $n_x$ 个 X， $n_y$ 个 Y，以 X 开头。
>         序列形如 `X Y X Y X Y ...`
>         长度限制于较少的那一方。
>         如果 $n_x == n_y$: `X Y X Y` -\> $2 n_x - 1$。
>         如果 $n_x > n_y$: `X Y X Y X` -\> $2 n_y$。
>         如果 $n_y \ge n_x$: `X Y X Y ... X Y Y Y` -\> $2 n_x$。
>
> 5.  **贪心流程**：
>     遍历 $1 \dots A+B$：
>
>       * 尝试放 'L'：
>           * 如果有剩余 L，且 (若放 L 后所需变化数 $\le$ L 开头剩余字符能提供的最大变化数)，则放 L。
>           * 否则，必须放 'Q'。
>           * 如果 'Q' 也放不了（没 Q 了，或者放 Q 也不满足 check），则无解（-1）。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 计算以 start_char (0 for L, 1 for Q) 开头，
// 剩余 cntL 个 L 和 cntQ 个 Q 能产生的最大变化次数
int get_max_changes(int cntL, int cntQ, int start_char) {
    if (cntL == 0 && cntQ == 0) return 0;
    if (cntL == 0) return (start_char == 0) ? 1 : 0; // L开头但没L了，不可能，逻辑上不会进这里除非被强行调用
    if (cntQ == 0) return (start_char == 1) ? 1 : 0;
    
    // 我们总是希望交替：L Q L Q ...
    // 如果 start = L (0)
    // 序列类似 L Q L Q ...
    // 能够形成的对数由较少的数量决定
    if (start_char == 0) { // Start with L
        if (cntL > cntQ) return 2 * cntQ;
        if (cntL == cntQ) return 2 * cntL - 1;
        if (cntQ > cntL) return 2 * cntL;
    } else { // Start with Q
        if (cntQ > cntL) return 2 * cntL;
        if (cntQ == cntL) return 2 * cntQ - 1;
        if (cntL > cntQ) return 2 * cntQ;
    }
    return 0;
}

// 修正最大变化次数计算逻辑
// 实际上，给定 nA, nB，开头字符确定的情况下：
// 如果以 A 开头：
// A B A B A ...
// 这种交替模式直到某一种字符耗尽。
// 如果 nA > nB: A B A B ... A (剩 A) -> 变化次数 = 2 * nB
// 如果 nB >= nA: A B A B ... B (剩 B) -> 变化次数 = 2 * nA (注意这里最后一项是 B，与前一个 A 构成变化)
//               特例：如果 nA == nB: A B A B -> 2 * nA - 1
// 让我们再仔细一点：
// nA=2, nB=2, Start A: A B A B (changes: 3) = 2*2 - 1. Correct.
// nA=3, nB=2, Start A: A B A B A (changes: 4) = 2*2. Correct.
// nA=2, nB=3, Start A: A B A B B (changes: 4) = 2*2. Correct.
// 总结：
// start X:
// if num(X) > num(Y): max_c = 2 * num(Y)
// if num(X) == num(Y): max_c = 2 * num(X) - 1
// if num(Y) > num(X): max_c = 2 * num(X)

int max_ch(int nx, int ny) { // 以 X 开头
    if (nx > ny) return 2 * ny;
    if (nx == ny) return 2 * nx - 1;
    return 2 * nx;
}

void solve() {
    int A, B, C;
    if (!(cin >> A >> B >> C)) return;

    string res = "";
    int curA = A, curB = B, curC = C;
    int last = -1; // -1: None, 0: L, 1: Q

    // 初始判断：全局最大可能变化数
    // 无论谁开头，最大变化数是 2 * min(A, B) + (A!=B ? (A+B>0?0:0) : -1)? 
    // 其实就是 max(max_ch(A, B), max_ch(B, A))
    // 对于 A=2, B=2, C=4 -> max is 3. Output -1.
    // max_ch(2, 2) = 3. 
    int global_max = max(max_ch(A, B), max_ch(B, A));
    if (A == 0 && B == 0) global_max = 0; // corner case
    
    // 还有一个限制：C 必须 <= global_max
    if (curC > global_max) {
        cout << -1 << endl;
        return;
    }

    for (int i = 0; i < A + B; i++) {
        bool placed = false;
        
        // 尝试放 L (0)
        if (curA > 0) {
            int next_cost = 0;
            if (last != -1 && last != 0) next_cost = 1;
            
            // 如果放了 L，剩余能否满足 C - next_cost
            if (curC >= next_cost) {
                int rem_max = max_ch(curA - 1, curB); 
                // 注意：这里 max_ch 默认以当前放的字符(L)开头计算后续最大能力
                // 因为后面紧接着 L 的就是后续序列的开头
                
                if (rem_max >= curC - next_cost) {
                    res += 'L';
                    curA--;
                    curC -= next_cost;
                    last = 0;
                    placed = true;
                }
            }
        }
        
        // 如果不能放 L，尝试放 Q (1)
        if (!placed && curB > 0) {
            int next_cost = 0;
            if (last != -1 && last != 1) next_cost = 1;
            
            if (curC >= next_cost) {
                int rem_max = max_ch(curB - 1, curA); // 以 Q 开头计算
                
                if (rem_max >= curC - next_cost) {
                    res += 'Q';
                    curB--;
                    curC -= next_cost;
                    last = 1;
                    placed = true;
                }
            }
        }
        
        if (!placed) {
            cout << -1 << endl;
            return;
        }
    }
    
    // 最后检查 C 是否刚好为 0
    if (curC == 0) cout << res << endl;
    else cout << -1 << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```
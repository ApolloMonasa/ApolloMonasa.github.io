---
title: 【打卡】第九天
weight: 9
date: 2025-12-06T16:23:00+08:00
---

## P8745 [蓝桥杯 2021 省 AB] 括号序列
> [点击此处跳转](https://www.luogu.com.cn/problem/P8745)

合法化的括号序列需要满足：
- 任意前缀中，`(` 的数量 $\ge$ `)` 的数量
- 任意后缀中，`(` 的数量 $\le$ `)` 的数量
- 整个序列中，`(` 的数量 $\equiv$ `)` 的数量

> [!NOTE] 知识点
> 动态规划、组合计数、前后缀分解

本题要求我们用最少的括号补全一个括号序列，并计算有多少种不同的补全方案。直接去思考在哪些位置插入括号，情况会非常复杂，而且很难做到不重不漏地计数。

这道题最巧妙的地方在于，它可以被拆分成两个**完全独立**的问题：
1.  **修复前缀**：我们需要在序列中添加最少的左括号 `(`，来保证从左到右的任意前缀中，`(` 的数量都不少于 `)` 的数量。
2.  **修复后缀**：我们需要在序列中添加最少的右括号 `)`，来保证从右到左的任意后缀中，`)` 的数量都不少于 `(` 的数量。

一个最终合法的序列，必须同时满足这两个条件。因为我们添加的括号种类不同（一个是 `(`，一个是 `)`)，它们的操作是正交的、互不影响。所以，最终的总方案数就是**两种修复方案数的乘积**。

更神奇的是，“修复后缀”的问题，只要我们把原字符串**反转**，再把所有括号**翻转**（`(`变`)`，`)`变`(`），它就变成了一个一模一样的“修复前缀”问题！这样我们就可以用同一个函数解决两个子问题了。

剩下的就是如何计算“修复前缀”的方案数 `solve()`。这里用了一个非常精妙的动态规划。我们先扫一遍字符串，算出为了保证前缀合法，在遇到每一个 `)` 时，我们**至少**需要有多少个 `(`（我们称之为“赤字”）。然后用DP来计算，在恰好满足这个最低要求的情况下，有多少种不同的添加 `(` 的方案。

> [!SUCCESS] Code
```cpp
#include <bits/stdc++.h>
typedef long long ll;
const int N=5010,Mod=1000000007;
using namespace std;
string s;      // 全局字符串，会被 rev() 函数修改
ll dp[N][N];   // DP 数组
int num[N],cnt; // 辅助数组和计数器
ll L,R;        // 分别存储两个子问题的答案

// solve() 函数计算 "修复前缀" 子问题的方案数
ll solve()
{
    int lcnt,rcnt; // lcnt: 可用的左括号数, rcnt: 左括号的"赤字"数
    lcnt=rcnt=0;
    memset(num,0,sizeof(num)); // 清空约束数组
    memset(dp,0,sizeof(dp));   // 清空DP数组
    cnt=0; // s中 ')' 的计数器

    // --- 步骤1: 预处理，计算每个 ')' 处的最小 '(' 添加量 ---
    // 遍历字符串 s，找到每个 ')' 对应的约束条件
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='(') lcnt++; // 遇到 '(', 可用数量增加
        else
        {
            rcnt++; // 遇到 ')', 赤字数先加1
            if(lcnt) { rcnt--; lcnt--; } // 如果有可用的 '(', 就用一个来匹配, 赤字数恢复
            num[++cnt]=rcnt; // 记录下遇到第 cnt 个 ')' 时的赤字数
        }
    }

    // --- 步骤2: 动态规划 ---
    // dp[i][j]: 考虑了 s 中前 i 个 ')', 且总共添加了 j 个 '(' 的方案数
    dp[0][0]=1; // base case: 在考虑任何 ')' 前, 添加0个 '(' 的方案是1 (即空串)

    for(int i=1;i<=cnt;i++) // 遍历 s 中的每一个 ')'
    {
        // 优化：将 dp[i-1] 行转换为其前缀和，方便后续O(1)计算区间和
        for(int j=num[i-1];j<=cnt;j++) // j 从 num[i-1] 开始，因为至少要添加这么多
        {
            if (j > 0) dp[i-1][j] += dp[i-1][j-1];
            dp[i-1][j] %= Mod;
        }

        // 状态转移
        for(int j=num[i];j<=cnt;j++) // j 必须满足当前 ')' 的约束
        {
            // dp[i][j] 的方案数，等于所有 dp[i-1][k] 的和,
            // 其中 k 满足 num[i-1] <= k <= j
            // 这里利用前缀和 O(1) 计算
            ll prev_sum = (dp[i-1][j] - (num[i-1] > 0 ? dp[i-1][num[i-1]-1] : 0)) % Mod + Mod;
            dp[i][j] += prev_sum;
            dp[i][j] %= Mod;
        }
    }

    // 题目要求最少添加，所以我们只取添加了恰好 num[cnt] 个 '(' 的方案数
    return dp[cnt][num[cnt]];
}

// rev() 函数将 "修复后缀" 问题转化为 "修复前缀" 问题
void rev()
{
    string tmp;
    tmp.clear();
    // 从后往前遍历 s, 同时翻转括号
    for(int i=s.length()-1;i>=0;i--)
        tmp.push_back(s[i]=='('?')':'(');
    s=tmp; // 更新全局字符串
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin>>s;

    // 计算修复前缀（添加 '('）的方案数
    L=solve();

    // 翻转字符串，准备计算修复后缀（添加 ')'）的方案数
    rev();

    // 计算修复后缀的方案数
    R=solve();

    // 两个独立的子问题，总方案数是两者的乘积
    cout<<L*R%Mod;
    
    return 0;
}

```









## P8763 [蓝桥杯 2021 国 ABC] 异或变换
> [点击此处跳转](https://www.luogu.com.cn/problem/P8763)

> [!NOTE] 考点
> 位运算、循环节、数学推理

这道题要求我们对一个`01`串进行多次异或变换，变换次数`t`可以非常大（`10^18`）。看到这种指数级的`t`，暴力模拟那是肯定要“寄飞”

如果学过数电就知道格雷码也是这样计算的，只不过需要反转一下，两者的方向不一样。又因为格雷码是循环码，所以不难猜到这个变换也是循环的，于是我们可以利用这个性质来做题。


### 规律

经过观察和数学推理（当然，这需要一些对帕斯卡三角形和模2组合数的了解），我们发现了这个异或变换的一个大秘密：每隔**特定次数**的变换，`01`串就会**变回最初的样子**！

这个“特定次数”是哪个数字呢？它总是某个“2的次方数”，比如`2, 4, 8, 16, 32...`。具体是哪一个，则取决于你的`01`串有多长`N`。

**规律就是：** 找到一个最小的`2`的次方数`X`，让`X`**大于等于**你的`01`串的长度`N`。那么，每隔`X`次变换，你的`01`串就会变回**最原始的状态**。

**举个例子，输入 `N=4, t=5`：**
1.  我们的串长`N=4`。
2.  找最小的`2`的次方数`X`，让`X >= N`：
* `2^1 = 2` (小于4)
* `2^2 = 4` (等于4)
3.  现在`t=5`。我们只需要关心`5`除以`4`的余数，也就是`1`。所以，`5`次变换后的结果，和`1`次变换后的结果是一模一样的！

### 算法

有了这个规律，解决问题就变得非常直接了：

1.  **第一步：找到周期 `X`**
* 你的代码里的 `while(x < n) x <<= 1;` 就是在找这个`X`。`x <<= 1` 就是`x = x * 2`，快速找到最小的`2`的次方数。

2.  **第二步：压缩`t`**
* `t = t % x;` 就是这个关键操作。现在`t`已经变得很小了（它一定小于`X`，最多也就`2N`左右），可以直接模拟

3.  **第三步：暴力模拟剩余`t`次**
    *   现在`t`已经被“降维”了。我们可以**直接模拟**这剩余的`t`次变换了。
    *   你的代码里的双重`for`循环就是这段模拟过程。**注意**，内层循环`for(int j=n-1; j>=1; j--)`是从右往左更新，这是为了确保在计算`s[j]`时，`s[j-1]`还是**上一轮变换**后的值，避免因为左边的字符被提前更新而导致错误。

这种方法将复杂度从天文数字(`O(N * T)`)直接降到了一个可以接受的范围(`O(N * X)`，其中`X`约等于`N`)，也就是`O(N^2)`级别。对于`N=10000`的`O(N^2)`，虽然看起来有点大，但在某些评测机上，配合优化的常数，是可能通过的。

> [!SUCCESS] Code
```cpp
#include<stdio.h>
long long n,t; // n: 串长, t: 变换次数
int x=1;       // x 将用于计算周期，初始化为 2^0 = 1
char s[10005]; // 存储 01 串，用 char 数组比 string 速度可能更快一点

int main(){
	scanf ("%lld%lld",&n,&t); // 读取 n 和 t
	scanf ("%s",s);           // 读取 01 串

    // --- 步骤1: 找出周期 X ---
    // 循环让 x 不断翻倍 (x = x * 2)，直到 x 大于等于 n
    // 此时 x 就是那个最小的 >= N 的 2 的次方数
	while(x<n) x<<=1; 
    
    // --- 步骤2: 压缩 t ---
    // t 对周期 X 取模，得到真正需要模拟的变换次数
    t=t%x; 
    
    // --- 步骤3: 暴力模拟剩余的 t 次变换 ---
	for(int i=0;i<t;i++) // 外层循环：模拟 t 次变换
		// 内层循环：对串中的每个字符施加变换
        // 从右往左遍历 (j 从 n-1 到 1)，确保 s[j-1] 是上一次变换后的值
		for(int j=n-1;j>=1;j--) 
			// 计算 s[j]' = s[j-1] ^ s[j]
            // 需要先转换为整数进行异或，再转换回字符存储
			s[j]=(s[j]-'0')^(s[j-1]-'0')+'0'; 
            
	printf ("%s",s); // 变换完成，打印最终的 01 串
	return 0;
}
```
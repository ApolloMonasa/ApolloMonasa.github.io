---
title: 【打卡】第九天
weight: 9
date: 2025-12-06T16:23:00+08:00
---

## P8745 [蓝桥杯 2021 省 AB] 括号序列
> [点击此处跳转](https://www.luogu.com.cn/problem/P8745)

合法化的括号序列需要满足：
- 任意前缀中，`(` 的数量 $\ge$ `)` 的数量
- 任意后缀中，`(` 的数量 $\le$ `)` 的数量
- 整个序列中，`(` 的数量 $\equiv$ `)` 的数量

> [!NOTE] 知识点
> 动态规划、组合计数、前后缀分解

本题要求我们用最少的括号补全一个括号序列，并计算有多少种不同的补全方案。直接去思考在哪些位置插入括号，情况会非常复杂，而且很难做到不重不漏地计数。

这道题最巧妙的地方在于，它可以被拆分成两个**完全独立**的问题：
1.  **修复前缀**：我们需要在序列中添加最少的左括号 `(`，来保证从左到右的任意前缀中，`(` 的数量都不少于 `)` 的数量。
2.  **修复后缀**：我们需要在序列中添加最少的右括号 `)`，来保证从右到左的任意后缀中，`)` 的数量都不少于 `(` 的数量。

一个最终合法的序列，必须同时满足这两个条件。因为我们添加的括号种类不同（一个是 `(`，一个是 `)`)，它们的操作是正交的、互不影响。所以，最终的总方案数就是**两种修复方案数的乘积**。

更神奇的是，“修复后缀”的问题，只要我们把原字符串**反转**，再把所有括号**翻转**（`(`变`)`，`)`变`(`），它就变成了一个一模一样的“修复前缀”问题！这样我们就可以用同一个函数解决两个子问题了。

剩下的就是如何计算“修复前缀”的方案数 `solve()`。这里用了一个非常精妙的动态规划。我们先扫一遍字符串，算出为了保证前缀合法，在遇到每一个 `)` 时，我们**至少**需要有多少个 `(`（我们称之为“赤字”）。然后用DP来计算，在恰好满足这个最低要求的情况下，有多少种不同的添加 `(` 的方案。

> [!SUCCESS] Code
```cpp
#include <bits/stdc++.h>
typedef long long ll;
const int N=5010,Mod=1000000007;
using namespace std;
string s;      // 全局字符串，会被 rev() 函数修改
ll dp[N][N];   // DP 数组
int num[N],cnt; // 辅助数组和计数器
ll L,R;        // 分别存储两个子问题的答案

// solve() 函数计算 "修复前缀" 子问题的方案数
ll solve()
{
    int lcnt,rcnt; // lcnt: 可用的左括号数, rcnt: 左括号的"赤字"数
    lcnt=rcnt=0;
    memset(num,0,sizeof(num)); // 清空约束数组
    memset(dp,0,sizeof(dp));   // 清空DP数组
    cnt=0; // s中 ')' 的计数器

    // --- 步骤1: 预处理，计算每个 ')' 处的最小 '(' 添加量 ---
    // 遍历字符串 s，找到每个 ')' 对应的约束条件
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='(') lcnt++; // 遇到 '(', 可用数量增加
        else
        {
            rcnt++; // 遇到 ')', 赤字数先加1
            if(lcnt) { rcnt--; lcnt--; } // 如果有可用的 '(', 就用一个来匹配, 赤字数恢复
            num[++cnt]=rcnt; // 记录下遇到第 cnt 个 ')' 时的赤字数
        }
    }

    // --- 步骤2: 动态规划 ---
    // dp[i][j]: 考虑了 s 中前 i 个 ')', 且总共添加了 j 个 '(' 的方案数
    dp[0][0]=1; // base case: 在考虑任何 ')' 前, 添加0个 '(' 的方案是1 (即空串)

    for(int i=1;i<=cnt;i++) // 遍历 s 中的每一个 ')'
    {
        // 优化：将 dp[i-1] 行转换为其前缀和，方便后续O(1)计算区间和
        for(int j=num[i-1];j<=cnt;j++) // j 从 num[i-1] 开始，因为至少要添加这么多
        {
            if (j > 0) dp[i-1][j] += dp[i-1][j-1];
            dp[i-1][j] %= Mod;
        }

        // 状态转移
        for(int j=num[i];j<=cnt;j++) // j 必须满足当前 ')' 的约束
        {
            // dp[i][j] 的方案数，等于所有 dp[i-1][k] 的和,
            // 其中 k 满足 num[i-1] <= k <= j
            // 这里利用前缀和 O(1) 计算
            ll prev_sum = (dp[i-1][j] - (num[i-1] > 0 ? dp[i-1][num[i-1]-1] : 0)) % Mod + Mod;
            dp[i][j] += prev_sum;
            dp[i][j] %= Mod;
        }
    }

    // 题目要求最少添加，所以我们只取添加了恰好 num[cnt] 个 '(' 的方案数
    return dp[cnt][num[cnt]];
}

// rev() 函数将 "修复后缀" 问题转化为 "修复前缀" 问题
void rev()
{
    string tmp;
    tmp.clear();
    // 从后往前遍历 s, 同时翻转括号
    for(int i=s.length()-1;i>=0;i--)
        tmp.push_back(s[i]=='('?')':'(');
    s=tmp; // 更新全局字符串
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin>>s;

    // 计算修复前缀（添加 '('）的方案数
    L=solve();

    // 翻转字符串，准备计算修复后缀（添加 ')'）的方案数
    rev();

    // 计算修复后缀的方案数
    R=solve();

    // 两个独立的子问题，总方案数是两者的乘积
    cout<<L*R%Mod;
    
    return 0;
}

```









## P8763 [蓝桥杯 2021 国 ABC] 异或变换
> [点击此处跳转](https://www.luogu.com.cn/problem/P8763)

> [!NOTE] 考点
>

> [!SUCCESS] Code
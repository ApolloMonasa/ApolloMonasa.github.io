---
title: 【打卡】第三天
weight: 3
date: 2025-11-30T12:06:00+08:00
---

## P8723 [蓝桥杯 2020 省 AB3] 乘法表
> [点击此处跳转](https://www.luogu.com.cn/problem/P8723)

> [!NOTE] 考点
> **进制转化算法**

最常用的进制转换算法可以概括为==取余除基，逆序排列==，比如，将十进制的 `9` 转化为 `4` 进制：
- `9 % 4 = 1`
- `9 / 4 = 2`
- `2 % 4 = 2`
- `2 / 4 = 0` (停止)
所以，我们需要一个辅助函数来进行这个转换，接收一个十进制数 `n` 和目标进制基数 `P`，返回一个字符串。只是这里如果余数大于 `9`，就要用大写字母表示，我们只需要加一个分支结构即可，具体看代码。

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-30
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

string to_base_P(int n, int p) {
    if (n == 0) {
        return "0";
    }
    string result = "";
    while (n > 0) {
        int remainder = n % p;
        if (remainder < 10) {
            result += (char)(remainder + '0');
        } else {
            result += (char)(remainder - 10 + 'A');
        }
        n /= p;
    }
    reverse(result.begin(), result.end());
    return result;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    int p;
    cin >> p;

    for (int i = 1; i < p; ++i) {
        for (int j = 1; j <= i; ++j) {
            int product = i * j;
            cout << to_base_P(i, p) << "*" << to_base_P(j, p) << "=" << to_base_P(product, p);
            if (j < i) {
                cout << " ";
            }
        }
        cout << "\n";
    }

    return 0;
}
```

## P8734 [蓝桥杯 2020 国 A] 奇偶覆盖
> [点击此处跳转](https://www.luogu.com.cn/problem/P8734)

> [!NOTE] 考点
> **扫描线**、**线段树**、**离散化**

本题要求计算平面上被奇数和偶数个矩形覆盖的面积，特征是坐标范围极大($10^9$)，任何基于坐标网格的暴力模拟都会==TLE==/==MLE==。这种坐标范围大但有效矩形数量有限的几何问题，通常使用**扫描线算法**。

扫描线算法的核心思想是**降维**。我们想象一条垂直的扫描线从左到右扫过整个平面。只有在遇到矩形的**左边界或右边界**时，**平面上被覆盖的情况才会发生改变**。我们**将这些边界的x坐标看作“事件点”，在两个相邻事件点之间的区域，y轴上的覆盖情况是恒定的**。

因此，问题转化为：**在每个由事件点分割出的竖直条带内，计算y轴上被奇数/偶数次覆盖的长度，再乘以条带的宽度，累加到总面积中。**

为了高效维护和查询y轴上的覆盖长度，我们通常会使用线段树:
1. **离散化**：y的坐标范围极大，我们不可能用线段树维护那么大的区间，但是我们注意到y的取值情况不超过$2 \times 10^5$，那么我们通常使用**离散化**的技巧，这样我们只用开$4 \times 10^5$个节点。
2. **线段树节点设计**：除了线段树节点常规信息，针对此题还需要维护以下信息：
    - `cover`: 区间被覆盖的层数
    - `union_len`: 区间被至少一层覆盖的总长度
    - `odd_len`: 区间被奇数层覆盖的总长度
    - `lazy_flip`: 一个标记，表示该区间的奇偶性是否需要反转，当一个区间被一个新的矩形覆盖时，其内部原本奇数覆盖的部分变为偶数，偶数部分变为奇数。这个标记可以高效地处理这种变化。
3. **最终计算**：扫描线每移动一步，我们就从线段树的根节点查询出当前的`union_len`和`odd_len`，乘以移动的距离`dx`，分别累加到总面积和奇数覆盖面积中。最后，偶数覆盖面积可以通过 `总覆盖面积 - 奇数覆盖面积` 得到。
> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-30 12:42:33
 @Mail:        apollomonasa@gmail.com
 @Description: cf template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// --- 事件定义 ---
struct Event {
    ll y1, y2;
    int x;
    int type; // +1 表示左边界, -1 表示右边界
};

// --- 全局变量 ---
vector<ll> y_coords; // 存储离散化后的y坐标

// --- 修改后的线段树模板 ---
#define LC(i) (tree[i].lc)
#define RC(i) (tree[i].rc)
#define L(i) (tree[i].l)
#define R(i) (tree[i].r)
#define Cover(i) (tree[i].cover)
#define UnionLen(i) (tree[i].union_len)
#define OddLen(i) (tree[i].odd_len)
#define LazyFlip(i) (tree[i].lazy_flip)

struct Node {
    int cover;       // 懒惰标记: 区间被完整覆盖的层数
    ll union_len;    // 区间内被覆盖>=1的总长度
    ll odd_len;      // 区间内被奇数层覆盖的总长度
    bool lazy_flip;  // 懒惰标记: 奇偶性是否需要翻转
    int lc, rc, l, r;
} tree[400005]; // 2*n个y坐标，需要大约2*(2n)空间
int ncnt = 1;

// 辅助函数：获取节点代表的y轴区间实际长度
inline ll get_len(int ind) {
    return y_coords[R(ind)] - y_coords[L(ind) - 1];
}

// 向上更新
inline void push_up(int ind) {
    // 1. 更新 union_len
    if (Cover(ind) > 0) {
        UnionLen(ind) = get_len(ind);
    } else if (L(ind) == R(ind)) { // 叶子节点且未被覆盖
        UnionLen(ind) = 0;
    } else {
        UnionLen(ind) = UnionLen(LC(ind)) + UnionLen(RC(ind));
    }

    // 2. 更新 odd_len
    if (L(ind) == R(ind)) { // 叶子节点
        OddLen(ind) = 0; // 初始状态，由lazy_flip决定
    } else {
        OddLen(ind) = OddLen(LC(ind)) + OddLen(RC(ind));
    }
    
    if (LazyFlip(ind)) {
        OddLen(ind) = UnionLen(ind) - OddLen(ind);
    }
}

// 向下传递懒惰标记
inline void push_down(int ind) {
    if (L(ind) == R(ind)) return; // 叶子节点无处可传

    if (Cover(ind) != 0) {
        Cover(LC(ind)) += Cover(ind);
        Cover(RC(ind)) += Cover(ind);
        Cover(ind) = 0;
    }

    if (LazyFlip(ind)) {
        LazyFlip(LC(ind)) = !LazyFlip(LC(ind));
        LazyFlip(RC(ind)) = !LazyFlip(RC(ind));
        LazyFlip(ind) = false;
    }
    // push_down后，子节点的值需要立即更新以反映新标记
    push_up(LC(ind));
    push_up(RC(ind));
}

void build(int ind, int l, int r) {
    L(ind) = l;
    R(ind) = r;
    Cover(ind) = 0;
    UnionLen(ind) = 0;
    OddLen(ind) = 0;
    LazyFlip(ind) = false;

    if (l == r) {
        LC(ind) = RC(ind) = 0;
        return;
    }
    LC(ind) = ++ncnt;
    RC(ind) = ++ncnt;
    int mid = l + (r - l) / 2;
    build(LC(ind), l, mid);
    build(RC(ind), mid + 1, r);
}

void mod(int ind, int x, int y, int d) {
    if (x <= L(ind) && R(ind) <= y) {
        Cover(ind) += d;
        LazyFlip(ind) = !LazyFlip(ind);
        push_up(ind);
        return;
    }

    // push_down(ind); // 在递归前传递标记
    // 实际上，这个特定问题的push_up已经包含了lazy_flip的效果，
    // 我们可以简化，在递归前不推，只在修改时更新
    
    int mid = L(ind) + (R(ind) - L(ind)) / 2;
    if (x <= mid) mod(LC(ind), x, y, d);
    if (y > mid) mod(RC(ind), x, y, d);
    push_up(ind);
}


void slv() {
    int n; cin >> n;
    vector<Event> events;
    y_coords.reserve(2 * n);

    for (int i = 0; i < n; ++i) {
        ll l, b, r, t; cin >> l >> b >> r >> t;
        events.push_back({b, t, (int)l, 1});
        events.push_back({b, t, (int)r, -1});
        y_coords.push_back(b);
        y_coords.push_back(t);
    }

    // 离散化操作
    sort(y_coords.begin(), y_coords.end());
    y_coords.erase(unique(y_coords.begin(), y_coords.end()), y_coords.end());
    //将事件安装x坐标大小升序排列
    sort(events.begin(), events.end(), [](const Event& a, const Event& b) {
        return a.x < b.x;
    });

    int m = y_coords.size();
    build(1, 1, m - 1); // m个坐标点，构成 m-1 个基本区间

    ll Odd = 0; // 奇覆盖面积
    ll S = 0;   // 总面积

    for (size_t i = 0; i < events.size(); ++i) {
        if (i > 0) {
            ll dx = events[i].x - events[i - 1].x;
            if (dx > 0) {
                S += UnionLen(1) * dx;
                Odd += OddLen(1) * dx;
            }
        }
        
        auto it_y1 = lower_bound(y_coords.begin(), y_coords.end(), events[i].y1);
        auto it_y2 = lower_bound(y_coords.begin(), y_coords.end(), events[i].y2);
        
        int y1_idx = distance(y_coords.begin(), it_y1) + 1; // 线段树维护的区间序号是从1开始的
        int y2_idx = distance(y_coords.begin(), it_y2); // 区间是[y1_idx, y2_idx]
        
        if (y1_idx <= y2_idx) {
            mod(1, y1_idx, y2_idx, events[i].type);
        }
    }

    ll Even = S - Odd;
    cout << Odd << "\n";
    cout << Even << "\n";
}


int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    slv();
}


```
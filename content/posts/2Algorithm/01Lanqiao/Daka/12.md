---
title: 【打卡】第十二天
weight: 12
date: 2025-12-09T16:06:00+08:00
---

## P12337 [蓝桥杯 2025 省 AB/Python B 第二场] 密密摆放

> [点击此处跳转](https://www.luogu.com.cn/problem/P12337)

### 题目描述

小蓝有一个大箱子，内部的长宽高分别是 $200$、$250$、$240$（单位：毫米），他要用这个大箱子来放一些同样大小的小盒子，小盒子的外部长宽高分别是 $30$、$40$、$50$（单位：毫米）。小盒子允许从各个方向旋转（包括可以平放和倒放）。

请问小蓝最多可以在一个大箱子里面放多少个小盒子。

> [!NOTE] 考点
> **几何计算**、**体积估算与分割**
>
> 1.  **体积上界估算**：
>     大箱子体积 $V_{big} = 200 \times 250 \times 240 = 12,000,000$。
>     小盒子体积 $V_{small} = 30 \times 40 \times 50 = 60,000$。
>     理论最大数量 $Max = V_{big} / V_{small} = 200$。
>     答案不可能超过 $200$。
>
> 2.  **整除验证**：
>     我们需要尝试是否有一种摆放方式（旋转小盒子），使得大箱子的长、宽、高分别能被小盒子的对应边长整除。
>     小盒子的边长集合为 $\{30, 40, 50\}$。
>     大箱子的边长集合为 $\{200, 250, 240\}$。
>
>     观察以下对应关系：
>
>       * $200 \div 40 = 5$ （整除）
>       * $250 \div 50 = 5$ （整除）
>       * $240 \div 30 = 8$ （整除）
>
>     这意味着，如果我们统一将小盒子按 $40 \times 50 \times 30$ 的方向摆放，大箱子正好可以放下 $5 \times 5 \times 8 = 200$ 个小盒子，没有任何空间浪费。
>
>     既然找到了一个可行解等于理论上界，那么最大值就是 $200$。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

void solve() {
    // 那还说啥了，直接输出吧
    cout << 200 << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    solve();
    return 0;
}
```


## P12832 [蓝桥杯 2025 国 B] 数字轮盘

> [点击此处跳转](https://www.luogu.com.cn/problem/P12832)

### 题目描述

给定一个长度为 $N$ 的数字轮盘，初始状态为 $1, 2, \ldots, N$。
先顺时针旋转 $K$ 次（相当于将序列循环右移 $K$ 位）。
然后求最少进行多少次“恢复操作”能变回初始状态。
恢复操作包含两步：翻转前 $N-1$ 个数，再翻转后 $N-1$ 个数。

> [!NOTE] 考点
> **模拟**、**找规律**、**奇偶性分析**
>
> 1.  **状态定义**：
>     由于操作是在圆盘上进行的，我们可以通过追踪数字 $1$ 所在的位置来定义当前状态。
>     初始时（未旋转），$1$ 在索引 $0$ 处。
>     旋转 $K$ 次后，序列向右移动 $K$ 位，$1$ 的位置变为了 $start = K \pmod N$（假设下标为 $0 \sim N-1$）。
>     我们的目标是将 $1$ 的位置变回 $0$。
>
> 2.  **操作分析**：
>     设当前 $1$ 的位置为 $p$。进行一次完整的“恢复操作”（两步翻转）后，$1$ 的位置 $p$ 会如何变化？
>     经过推导（见代码注释逻辑），位置变换规律如下：
>
>       * 若 $p = N-2$，经过一次操作变为 $0$（直接复原）。
>       * 若 $p = N-1$，经过一次操作变为 $1$。
>       * 若 $1 \le p < N-2$，经过一次操作变为 $p+2$。
>       * 若 $p = 0$，已经是目标状态。
>
> 3.  **路径搜索与奇偶性**：
>     我们拥有的移动能力主要是 $+2$。这意味着我们只能在同奇偶性的位置上移动。
>
>       * **直接路径**：如果 $start$ 与 $N$ 同奇偶（即 $start$ 与 $N-2$ 同奇偶），我们可以通过 $+2$ 一路走到 $N-2$，最后一步跳到 $0$。
>           * 步数 = $(N - 2 - start) / 2 + 1$。
>       * **变道路径**：如果 $start$ 与 $N$ 奇偶性不同，我们必须利用 $N-1 \to 1$ 这个特殊的跳转来改变奇偶性。
>           * 首先，从 $start$ 走到 $N-1$（需要 $start$ 与 $N-1$ 同奇偶）。
>           * 然后，$N-1 \to 1$（改变了奇偶性）。
>           * 最后，从 $1$ 走到 $N-2$（需要 $1$ 与 $N-2$ 同奇偶）。
>
>     综上，如果 $N$ 是偶数，且 $start$ 是奇数（奇偶不同），我们试图走 $N-1 \to 1$。但 $N-1$ 是奇数，$1$ 是奇数，这没问题；可是到了 $1$ 之后，我们需要去 $N-2$（偶数），这在 $+2$ 规则下是不可能的。因此，**当 $N$ 为偶数且 $start$ 为奇数时，无解**。
>     当 $N$ 为奇数时，无论 $start$ 是奇是偶都有解。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-08 10:57:00
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

void solve() {
    ll N, K;
    if (!(cin >> N >> K)) return;

    // 1 的初始位置 (0-based index)
    // 原始序列 1, 2, ..., N. 旋转 K 次相当于右移 K 位。
    // 1 原本在 0，右移 K 位后在 K % N。
    ll start = K % N;

    // 已经复原
    if (start == 0) {
        cout << 0 << endl;
        return;
    }

    // 检查奇偶性
    // 目标是到达 N-2 (然后 +1 步归零)
    // 主要移动方式是 +2，所以通常保持奇偶性不变。
    // 唯一改变奇偶性的路径是: ... -> N-1 -> 1 -> ...
    
    // 情况 1: start 和 N 同奇偶 (即 start 和 N-2 同奇偶)
    // 可以直接通过 +2 走到 N-2
    if (start % 2 == N % 2) {
        // 步数计算: 
        // 距离 (N-2) 的差值是 (N - 2 - start)
        // 每次 +2，步数为差值 / 2
        // 最后从 N-2 到 0 需要额外 1 步
        cout << (N - 2 - start) / 2 + 1 << endl;
    }
    else {
        // 情况 2: start 和 N 奇偶性不同
        // 必须经过 N-1 -> 1 进行“换道”
        
        // 如果 N 是偶数，那么 start 是奇数。
        // 我们能走到 N-1 (奇数)，然后跳到 1 (奇数)。
        // 但是从 1 (奇数) 无法走到 N-2 (偶数)。
        // 所以 N 为偶数时无解。
        if (N % 2 == 0) {
            cout << -1 << endl;
        } 
        else {
            // N 是奇数，start 是偶数。
            // 路径: start -> ... -> N-1 -> 1 -> ... -> N-2 -> 0
            
            ll steps = 0;
            // 第一阶段: start -> N-1
            // 距离: N - 1 - start
            steps += (N - 1 - start) / 2;
            
            // 第二阶段: N-1 -> 1
            steps += 1;
            
            // 第三阶段: 1 -> N-2
            // 距离: N - 2 - 1 = N - 3
            steps += (N - 3) / 2;
            
            // 第四阶段: N-2 -> 0
            steps += 1;
            
            cout << steps << endl;
        }
    }
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int t;
    if (cin >> t) {
        while(t--) {
            solve();
        }
    }
    return 0;
}
```





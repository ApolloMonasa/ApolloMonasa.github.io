---
title: 【打卡】第六天
weight: 6
date: 2025-12-03T21:06:00+08:00
---

## P10424 [蓝桥杯 2024 省 B] 好数
> [点击此处跳转](https://www.luogu.com.cn/problem/P10424)

> [!NOTE] 考点
> 模拟\数位DP

注意到本题的数据范围是 `N < 10^7`，所以我们遍历每个数然后检查每一位的计算次数不超过 `7*10^7`，而现代计算机一秒大概可以进行 `10^8` 次计算，所以是可以在题目限时内完成计算的，故第一种办法就是暴力模拟。

但是如果这题难度加大，加大数据规模，我们暴力的方法就不能通过了，所以我们还要介绍`数位dp`的做法，这是是经典dp中的一种。
> 数位dp的核心思想就是一种`按位记忆化搜索`，我们不直接遍历从`1`到`N`所有数，而是构造满足要求的的数。为了方便按位处理，我们通常将`N`转换为字符串`S`，我们的目标是计算`[1, N]`区间内好数的个数，这可以分解为两个子问题:
> - 计算位数小于 `N` 的好数个数
> - 计算位数等于 `N` 但数值小于 `N` 的好数个数

### 计算位数小于`N`的好数个数

这部分就是组合计数，没有什么困难。

> [!PRIMARY] 规律
> 对于一个 `k` 位好数
> - 最高位(第 `k` 位)有 `4` 或 `5` 种选择(取决于 `k` 的奇偶性以及高位非零性质)
> - 其余的位都有 `5` 种选择

### 计算位数与 `N` 相同的好数

这部分是 `数位DP` 的核心，我们要从高位到低位构造一个和 `N` 位数相同的好数，同时保证它小于 `N`。
我们用一个循环从左到右遍历 `N` 的每一位。在遍历到第 `pos` 位时，我们需要一个 `is_lmt` 标记来告诉我们：
- `is_lmt == true` 表示我们之前填的数字和 `N` 的前缀完全一样。那么我们当前填的数字就不能超过 `S[pos]`，否则就违反了大小限制。
- 'is_lmt == false' 则表示当前位可以随便填
其他细节看代码即可。

> [!SUCCESS] Code1 暴力搜索
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:29:09
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 辅助函数，判断一个数是否为“好数”
bool is_good(int num) {
    int pos = 1; // 从右往左的位置，1-indexed
    while (num > 0) {
        int digit = num % 10;

        // 判断位置的奇偶性，并检查对应位的数字的奇偶性
        if (pos & 1) { // 奇数位
            if (digit & 1 == 0) { // 数字必须是奇数
                return false;
            }
        } else { // 偶数位
            if (digit & 1) { // 数字必须是偶数
                return false;
            }
        }

        num /= 10; // 去掉最后一位
        pos++;     // 位置加一
    }
    return true; // 所有位都满足条件
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    int n;
    cin >> n;

    int count = 0;
    for (int i = 1; i <= n; ++i) {
        if (is_good(i)) count++;
    }

    cout << count << endl;

    return 0;
}

```
> [!SUCCESS] Code2 数位DP
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:29:09
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 判断一个数字d是否可以放在从右数的第k位
bool is_valid_digit(int d, int k) {
    if (k & 1) { // 奇数位
        return d & 1 == 1;
    } else { // 偶数位
        return d & 1 == 0;
    }
}

ll solve(int n) {
    string s = to_string(n);
    int len = s.length();
    ll ans = 0;

    // Part 1: 计算所有位数小于len的好数
    for (int i = 1; i < len; ++i) {
        ll cnt = 1;
        // 最高位不能是0
        if (i & 1) { // 奇数位
            cnt = 5;
        } else { // 偶数位
            cnt = 4;
        }
        // 其余 i-1 位
        for (int j = 0; j < i - 1; ++j) {
            cnt *= 5;
        }
        ans += cnt;
    }

    // Part 2: 计算位数等于len，且小于等于n的好数
    bool is_lmt = true;
    for (int i = 0; i < len; ++i) {
        int pos_from_right = len - i;
        int limit = s[i] - '0';
        
        // 尝试填入数字 d
        for (int d = (i == 0 ? 1 : 0); d < limit; ++d) {
            if (is_valid_digit(d, pos_from_right)) {
                // 如果填入的d < limit，就不再受N的限制
                // 后面 len - 1 - i 位可以任意填
                ans += pow(5, len - 1 - i);
            }
        }
        
        // 检查limit本身是否合法
        if (is_valid_digit(limit, pos_from_right)) {
            // 如果合法，继续下一位的搜索，is_lmt 保持 true
            // 如果这是最后一位，说明N本身就是个好数，要加上它
            if (i == len - 1) {
                ans++;
            }
        } else {
            // 如果limit不合法，那么往后填充都不可能是好数了
            // 搜索提前终止
            break;
        }
    }

    return ans;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    int n;
    cin >> n;
    cout << solve(n) << endl;

    return 0;
}
```


## P10391 [蓝桥杯 2024 省 A] 零食采购
> [点击此处跳转](https://www.luogu.com.cn/problem/P10391)

> [!NOTE] 考点
> 状态压缩、最近公共祖先LCA、倍增

> 首先要认识到星球和航路构成了一颗树，要认识到这一点就要知道图论中关于树的基本定理：**一个拥有 `n` 个顶点和 `n - 1` 条边的无向图，当且仅当它是连通的，它才是一颗树。**


这道题要求我们计算在一棵树上，两个给定节点之间唯一路径上，有多少种不同的“零食种类”。考虑到星球数量 `n` 和查询次数 `q` 都可能高达 `10^5`，如果每次查询都通过遍历路径来计算，那么每次查询的时间复杂度是 `O(n)`，总时间会超时。因此，我们需要一个更高效的、带有预处理的算法。

### 核心思路：LCA + 位运算 (Bitmasking)

解决这个问题的关键在于抓住两个核心条件：
1.  星球和航路构成了一棵**树**，故任意两点间的路径是唯一的。
2.  零食的种类非常少，最多只有**20种**。

这两个条件的组合强烈地指向了 **最近公共祖先 (LCA)** 和 **位运算 (Bitmasking)** 相结合的解法。

**位运算**在这里能很好地处理“不同零食”这个集合问题。因为零食种类最多20种，我们可以用一个整数来表示一个零食的集合。例如，如果这个整数的二进制表示中，第 `k` 位是 `1`，就代表我们拥有第 `k+1` 种零食。两个零食集合的并集，就可以通过简单的**按位或 `|`** 运算来高效完成。

#### 一个常见的陷阱

一个很自然但错误的思路是：预处理出每个节点`u`从根到`u`的路径掩码`mask[u]`，然后在查询`(s, t)`时，直接计算`mask[s] | mask[t]`。这个做法的错误在于，它将`根 -> LCA`这段公共路径上的零食也包含了进来，但在`s`和`t`的路径上，我们并不需要这些`LCA`之上的节点。

#### 正确的思路：增强LCA的倍增信息

为了精确计算任意两点间的路径信息，我们必须在预处理LCA时，同步记录**路径段**的信息。

#### 1. 预处理阶段 (时间复杂度: O(N log N))

我们从根节点（随意选择一个星球即可）出发，进行一次深度优先搜索 (DFS)，并利用倍增法填充我们的信息表。

a.  **LCA 信息 (倍增法)**：我们计算每个星球的 `depth` (深度) 和 `pa[u][k]` 表，`pa[u][k]` 存储的是星球 `u` 的第 $2^k$ 个祖先。

b.  **路径段位掩码 (Path Segment Bitmasks)**：这是本题的关键。我们额外维护一个`mask[u][k]`表，它存储的不是从根出发的路径，而是**从星球 `u` 向上走到其第 $2^k$ 个祖先（即`pa[u][k]`）这段路径上**所有零食的集合。
* **基础 (k=0)**: `mask[u][0]` 存储 `u` 和它的直接父节点 `pa[u][0]` 上的零食。`mask[u][0] = (1 << c[u]-1) | (1 << c[pa[u][0]]-1)`。
* **递推 (k>0)**: 从`u`到`pa[u][k]`的路径可以拆分为`u`到`pa[u][k-1]`和`pa[u][k-1]`到`pa[u][k]`两段。所以：
    `mask[u][k] = mask[u][k-1] | mask[pa[u][k-1]][k-1]`

#### 2. 查询阶段 (时间复杂度: O(Q log N))

对于每一个查询`(s, t)`：

a.  **找到LCA**：首先用倍增法找到`LCA(s, t)`。

b.  **拼接路径掩码**：
- 我们需要分别计算 `s -> LCA` 和 `t -> LCA` 这两条路径的零食集合。
- 这可以通过“向上跳”的方式，利用我们预处理好的`mask[u][k]`表来高效完成。例如，要从`s`向上跳到`LCA`，我们就不断地跳`2^k`步，并把对应的`mask[s][k]`用`|`运算合并起来。
- 将 `s -> LCA` 的掩码和 `t -> LCA` 的掩码**按位或**起来。
- 最后，不要忘记LCA节点本身也在这条路径上，所以需要再**或**上LCA节点的零食 `(1 << (c[LCA] - 1))`。

c.  **统计不同零食的数量**：对最终得到的掩码，使用C++内置函数 `__builtin_popcount()` 来统计结果，需要记住，这是一个常用的内置工具。

通过这种方式，我们将每次查询的复杂度从 `O(N)` 降到了 `O(log N)`，足以在规定时间内解决问题。

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:28:57
 @Mail:        apollomonasa@gmail.com
 @Description: Codeforces template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

const int MAXN = 100005;
const int LOGN = 17; // 2^17 > 10^5，用于倍增

vector<int> adj[MAXN];    // 邻接表，存储树的结构
int c[MAXN];              // c[i] 存储星球 i 的零食种类
int depth[MAXN];          // depth[i] 存储星球 i 的深度
int pa[MAXN][LOGN];       // pa[i][k] 存储 i 的第 2^k 个祖先
int mask[MAXN][LOGN];     // 【核心】mask[i][k] 存储从 i 到 pa[i][k] 路径上的零食集合(位掩码)
int n, q;

// DFS用于预处理深度、父节点和基础掩码
void dfs(int u, int p, int d) {
    depth[u] = d;
    pa[u][0] = p;

    // 计算基础掩码: 从 u 到其直接父节点 p 的路径
    mask[u][0] = (1 << (c[u] - 1));
    if (p != 0) { // 如果不是根节点
        mask[u][0] |= (1 << (c[p] - 1));
    }

    for (int v : adj[u]) {
        if (v != p) {
            dfs(v, u, d + 1);
        }
    }
}

// 预处理LCA和路径掩码的倍增表
void preprocess() {
    dfs(1, 0, 0); 
    
    // pa[0][k] 应该为 0，防止跳出边界
    for (int k = 0; k < LOGN; ++k) pa[0][k] = 0;

    // 利用倍增法填充 pa 和 mask 表
    for (int k = 1; k < LOGN; ++k) {
        for (int i = 1; i <= n; ++i) {
            pa[i][k] = pa[pa[i][k-1]][k-1];
            mask[i][k] = mask[i][k-1] | mask[pa[i][k-1]][k-1];
        }
    }
}

// 查询u和v的LCA
int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);

    for (int k = LOGN - 1; k >= 0; --k) {
        if (depth[u] - (1 << k) >= depth[v]) {
            u = pa[u][k];
        }
    }

    if (u == v) return u;

    for (int k = LOGN - 1; k >= 0; --k) {
        if (pa[u][k] != pa[v][k]) {
            u = pa[u][k];
            v = pa[v][k];
        }
    }
    return pa[u][0];
}

void slv() {
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> c[i];
    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    preprocess();

    while (q--) {
        int s, t;
        cin >> s >> t;
        int LCA = lca(s, t);
        
        int final_mask = 0;

        // 计算从 s 向上到 LCA 路径的掩码
        for (int k = LOGN - 1; k >= 0; --k) {
            if (depth[s] >= depth[LCA] + (1 << k)) {
                final_mask |= mask[s][k];
                s = pa[s][k];
            }
        }

        // 计算从 t 向上到 LCA 路径的掩码
        for (int k = LOGN - 1; k >= 0; --k) {
            if (depth[t] >= depth[LCA] + (1 << k)) {
                final_mask |= mask[t][k];
                t = pa[t][k];
            }
        }
        
        // 最后，将LCA本身的零食加入集合
        final_mask |= (1 << (c[LCA] - 1));

        // 统计二进制位为1的个数
        cout << __builtin_popcount(final_mask) << "\n";
    }
}

int main() {
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    slv();
    return 0;
}
```
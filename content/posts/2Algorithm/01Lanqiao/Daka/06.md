---
title: 【打卡】第六天
weight: 6
date: 2025-12-03T21:06:00+08:00
---

## P10424 [蓝桥杯 2024 省 B] 好数
> [点击此处跳转](https://www.luogu.com.cn/problem/P10424)

> [!NOTE] 考点
> 模拟\数位DP

注意到本题的数据范围是 `N < 10^7`，所以我们遍历每个数然后检查每一位的计算次数不超过 `7*10^7`，而现代计算机一秒大概可以进行 `10^8` 次计算，所以是可以在题目限时内完成计算的，故第一种办法就是暴力模拟。

但是如果这题难度加大，加大数据规模，我们暴力的方法就不能通过了，所以我们还要介绍`数位dp`的做法，这是是经典dp中的一种。
> 数位dp的核心思想就是一种`按位记忆化搜索`，我们不直接遍历从`1`到`N`所有数，而是构造满足要求的的数。为了方便按位处理，我们通常将`N`转换为字符串`S`，我们的目标是计算`[1, N]`区间内好数的个数，这可以分解为两个子问题:
> - 计算位数小于 `N` 的好数个数
> - 计算位数等于 `N` 但数值小于 `N` 的好数个数

### 计算位数小于`N`的好数个数

这部分就是组合计数，没有什么困难。

> [!PRIMARY] 规律
> 对于一个 `k` 位好数
> - 最高位(第 `k` 位)有 `4` 或 `5` 种选择(取决于 `k` 的奇偶性以及高位非零性质)
> - 其余的位都有 `5` 种选择

### 计算位数与 `N` 相同的好数

这部分是 `数位DP` 的核心，我们要从高位到低位构造一个和 `N` 位数相同的好数，同时保证它小于 `N`。
我们用一个循环从左到右遍历 `N` 的每一位。在遍历到第 `pos` 位时，我们需要一个 `is_lmt` 标记来告诉我们：
- `is_lmt == true` 表示我们之前填的数字和 `N` 的前缀完全一样。那么我们当前填的数字就不能超过 `S[pos]`，否则就违反了大小限制。
- 'is_lmt == false' 则表示当前位可以随便填
其他细节看代码即可。

> [!SUCCESS] Code1 暴力搜索
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:29:09
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 辅助函数，判断一个数是否为“好数”
bool is_good(int num) {
    int pos = 1; // 从右往左的位置，1-indexed
    while (num > 0) {
        int digit = num % 10;

        // 判断位置的奇偶性，并检查对应位的数字的奇偶性
        if (pos & 1) { // 奇数位
            if (digit & 1 == 0) { // 数字必须是奇数
                return false;
            }
        } else { // 偶数位
            if (digit & 1) { // 数字必须是偶数
                return false;
            }
        }

        num /= 10; // 去掉最后一位
        pos++;     // 位置加一
    }
    return true; // 所有位都满足条件
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    int n;
    cin >> n;

    int count = 0;
    for (int i = 1; i <= n; ++i) {
        if (is_good(i)) count++;
    }

    cout << count << endl;

    return 0;
}

```
> [!SUCCESS] Code2 数位DP
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:29:09
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 判断一个数字d是否可以放在从右数的第k位
bool is_valid_digit(int d, int k) {
    if (k & 1) { // 奇数位
        return d & 1 == 1;
    } else { // 偶数位
        return d & 1 == 0;
    }
}

ll solve(int n) {
    string s = to_string(n);
    int len = s.length();
    ll ans = 0;

    // Part 1: 计算所有位数小于len的好数
    for (int i = 1; i < len; ++i) {
        ll cnt = 1;
        // 最高位不能是0
        if (i & 1) { // 奇数位
            cnt = 5;
        } else { // 偶数位
            cnt = 4;
        }
        // 其余 i-1 位
        for (int j = 0; j < i - 1; ++j) {
            cnt *= 5;
        }
        ans += cnt;
    }

    // Part 2: 计算位数等于len，且小于等于n的好数
    bool is_lmt = true;
    for (int i = 0; i < len; ++i) {
        int pos_from_right = len - i;
        int limit = s[i] - '0';
        
        // 尝试填入数字 d
        for (int d = (i == 0 ? 1 : 0); d < limit; ++d) {
            if (is_valid_digit(d, pos_from_right)) {
                // 如果填入的d < limit，就不再受N的限制
                // 后面 len - 1 - i 位可以任意填
                ans += pow(5, len - 1 - i);
            }
        }
        
        // 检查limit本身是否合法
        if (is_valid_digit(limit, pos_from_right)) {
            // 如果合法，继续下一位的搜索，is_lmt 保持 true
            // 如果这是最后一位，说明N本身就是个好数，要加上它
            if (i == len - 1) {
                ans++;
            }
        } else {
            // 如果limit不合法，那么往后填充都不可能是好数了
            // 搜索提前终止
            break;
        }
    }

    return ans;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    int n;
    cin >> n;
    cout << solve(n) << endl;

    return 0;
}
```

## P10391 [蓝桥杯 2024 省 A] 零食采购
> [点击此处跳转](https://www.luogu.com.cn/problem/P10391)

> [!NOTE] 考点
> 状态压缩DP、最近公共祖先LCA

> [!SUCCESS] Code
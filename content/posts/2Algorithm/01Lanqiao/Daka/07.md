---
title: 【打卡】第七天
weight: 7
date: 2025-12-04T16:06:00+08:00
---

## P10425 [蓝桥杯 2024 省 B] R 格式
> [点击此处跳转](https://www.luogu.com.cn/problem/P10425)

> 本题乍一看很简单，很容易直接写出 `round(d * pow(2, n))`这样的答案，可是一提交就会发现只有40分，回到题面一看就发现这题 `n` 可以到恐怖的 `1000`，肯定会溢出的，所以要用高精度乘法。

> [!NOTE] 考点
> 高精度乘法

此处只用到乘2的功能，所以只需要写一个乘2的逻辑，也可以不像我这样写，而把进位的逻辑单独封装成一个函数，减少代码重复冗余。


> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-04 16:59:13
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// 高精度乘2函数
void mul2(vector<int>& num) {
    int carry = 0;
    int digits = num.size();
    for (size_t i = 0; i < digits; i++) {
        int val = num[i] * 2 + carry;
        num[i] = val % 10;
        carry = val / 10;
    }
    while (carry) {
        num.push_back(carry % 10);
        carry /= 10;
    }
}


int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int n; string d; cin >> n >> d;
    
    vector<int> num;
    size_t dot = d.find('.');
    int k = 0; // 小数位数
    if (dot != string::npos) k = d.length() - (dot + 1);

    for (int i = d.length() - 1; i >= 0; i--) {
        if (d[i] != '.') num.push_back(d[i] - '0');
    }

    for (int i = 0; i < n; i++) {
        mul2(num);
    }

    if (k > 0 && num[k - 1] >= 5) {
        int carry = 1;
        int digits = num.size();
        for (size_t i = k; i < digits; i++) {
            if (carry == 0) break;
            int val = num[i] + carry;
            num[i] = val % 10;
            carry = val / 10;
        }
        if (carry > 0) num.push_back(carry);
    }

    for (int i = num.size() - 1; i >= k; i--) cout << num[i];
    cout << endl;
}
```

> [!NOTE] 另一种写法
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-04 16:59:13
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

// digit_process
void process(vector<int>& num) {
    for (size_t  i = 0; i < num.size(); i++) {
        if (num[i] >= 10) {
            if (i + 1 == num.size()) num.push_back(0);
            num[i + 1] += num[i] / 10;
            num[i] %= 10;
        }
    }
}


// 高精度乘2函数
void mul2(vector<int>& num) {
    for (size_t i = 0; i < num.size(); i++) num[i] *= 2;
    process(num);
}


int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int n; string d; cin >> n >> d;
    
    vector<int> num;
    size_t dot = d.find('.');
    int k = 0; // 小数位数
    if (dot != string::npos) k = d.length() - (dot + 1);

    for (int i = d.length() - 1; i >= 0; i--) {
        if (d[i] != '.') num.push_back(d[i] - '0');
    }

    for (int i = 0; i < n; i++) {
        mul2(num);
    }

    if (k > 0 && num[k - 1] >= 5) {
        num[k] += 1;
        process(num);
    }
    for (int i = num.size() - 1; i >= k; i--) cout << num[i];
    
    cout << endl;
}
```


## P9422 [蓝桥杯 2023 国 B] 合并数列
> [点击此处跳转](https://www.luogu.com.cn/problem/P9422)

> [!NOTE] 考点
> 双指针

本题要把两个数组变得一样就从左往右遍历，如果发现某一位不一样，就开始合并，那肯定是小的那方和它后面的数合并，所以双指针可以解决。

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-04 17:37:59
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int n, m; cin >> n >> m;
    vector<int> a(n), b(m);
    for (auto &x : a) cin >> x;
    for (auto &x : b) cin >> x;

    int i = 0, j = 0;
    ll sum_a = 0, sum_b = 0;
    int final_len = 0;

    // 只要两个指针都还在界内
    while (i < n || j < m) {
        // 如果两个块相等，或者都是0（初始或刚匹配完），加载新元素
        if (sum_a == sum_b) {
            sum_a += a[i++];
            sum_b += b[j++];
        } else if (sum_a < sum_b) {
            sum_a += a[i++];
        } else { // sum_b < sum_a
            sum_b += b[j++];
        }

        // 如果加载完新元素后，两个块相等了，说明我们找到了一个同步点
        if (sum_a == sum_b) {
            final_len++;
            sum_a = 0;
            sum_b = 0;
        }
    }
    
    // 如果循环结束后还有未清零的sum，说明最后一块也匹配上了
    if (sum_a != 0 || sum_b != 0) {
       // 这种情况不会发生，因为题目保证了总和相等，
       // 所以最后一个块也必然会匹配并被清零。
    }

    int operations = (n - final_len) + (m - final_len);
    cout << operations << endl;

}
```
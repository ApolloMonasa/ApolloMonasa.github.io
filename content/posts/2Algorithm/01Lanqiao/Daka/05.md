---
title: 【打卡】第五天
weight: 5
date: 2025-12-02T20:06:00+08:00
---

## P9421 [蓝桥杯 2023 国 B] 班级活动
> [点击此处跳转](https://www.luogu.com.cn/problem/P9421)

> [!NOTE] 考点
> 贪心、数学

贪心算法是范围最宽泛的算法，任何 `optimize` 向的题面都可以归为贪心一类。本题就是要最小化 `id` 修改数量，抽象一下就是输入一个数组，然后算出最少修改几个数字就可以让其中的数字一一对应(任何id出现且仅出现两次)。我们可以采取这样的贪心策略：
- 本就配对的数字不动
- 那么需要处理的就是两类，一类是 `id` 仅仅出现了一次，另一类就是总出现次数超过两次导致的落单，这两类都需要处理，我们记录这样的数字数量为 `single_pool`
- 与此同时我我们还要记录上述两类中前者的数量，它的 `id` 是没有被占用的，我们记为 `free`
- 当`free`过少，说明落单数字中大多数是id被占用的，这样的数字都要修改。
- 当`free`足够多，说明我们可以直接修改其他的数来适配这些拥有`自由id`的数
- 而这个界限就是 `single_pool` 的一半，读者可以稍加思考为何。

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-12-02 11:43:45
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int n; cin >> n;
    map<int, int> cnt;
    for (int i = 0, a; i < n; i++) {
        cin >> a;
        cnt[a]++;
    }
    int single_pool = 0;
    int free = 0;

    for (auto &[a, b] : cnt) {
        if (b > 2) {
            single_pool += b - 2;
        } else if (b == 1) {
            single_pool++;
            free++;
        }
    }

    // int ans = free + single_pool - free * 2;
    int ans = max(single_pool - free, single_pool / 2); // 至少要修改一半，只是没有自由id的都需要改，故取较大值
    cout << ans << endl;

}

```
## P8796 [蓝桥杯 2022 国 AC] 替换字符
> [点击此处跳转](https://www.luogu.com.cn/problem/P8796)

> [!NOTE] 考点
> 线段树

本题和其他线段树都不一样的点在于这里维护的是一个映射表，来表示字母的替换，在`put_down`下放懒标记操作时，我们用到的一个嵌套的操作，即父节点的映射要嵌套在子节点映射之上。具体看代码：

> [!SUCCESS] Code

```cpp

/*
 @Author:      ApolloMonasa
 @Date:        2025-12-02 22:31:10
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

const int N = 1e5+5;

struct Node {
    array<int, 26> mp;
    Node() {
        iota(mp.begin(), mp.end(), 0);
    }
};

Node tree[4 * N];
string s;

inline void compound(array<int, 26>& ch, const array<int, 26>& pa) {
    for (int i = 0; i < 26; i++) {
        ch[i] = pa[ch[i]];
    }
}

void down(int u) {
    compound(tree[u * 2].mp, tree[u].mp);
    compound(tree[u * 2 + 1].mp, tree[u].mp);
    iota(tree[u].mp.begin(), tree[u].mp.end(), 0);
}

void mod(int u, int l, int r, int ql, int qr, int x, int y) {
    if (ql <= l && r <= qr) {
        for (int i = 0; i < 26; i++) {
            if (tree[u].mp[i] == x) tree[u].mp[i] = y;
        }
        return ;
    }

    down(u);
    int mid = l + ((r - l) >> 1);
    if (ql <= mid) mod(u * 2, l, mid, ql, qr, x, y);
    if (qr > mid) mod(u * 2 + 1, mid + 1, r, ql, qr, x, y);
}


char ask(int u, int l, int r, int pos) {
    if (l == r) return (char)('a' + tree[u].mp[s[pos - 1] - 'a']);

    down(u);
    int mid = l + ((r - l) >> 1);
    if (pos <= mid) return ask(u * 2, l, mid, pos);
    else return ask(u * 2 + 1, mid + 1, r, pos);

}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    int m, n, l, r, x, y;
    char x_c, y_c;

    cin >> s >> m;
    n = s.size();

    while (m--) {
        cin >> l >> r >> x_c >> y_c;
        x = x_c - 'a';
        y = y_c - 'a';
        if (x != y) {
            mod(1, 1, n, l, r, x, y);
        }
    }   
    for (int i = 0; i < n; i++) {
        cout << ask(1, 1, n, i + 1);
    }
    cout << endl;
}
```
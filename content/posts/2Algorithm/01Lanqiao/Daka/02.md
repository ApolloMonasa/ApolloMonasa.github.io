---
title: 【打卡】第二天
weight: 2
date: 2025-11-29T23:06:00+08:00
---

## P8615 [蓝桥杯 2014 国 C] 拼接平方数
> [点击此处跳转](https://www.luogu.com.cn/problem/P8615)

> [!NOTE] 考点
> 字符串操作、枚举

这题要求我们找到一个区间 `[a, b]` 内所有的拼接平方数，所谓拼接平方数，即:
- 它本身是完全平方数
- 它可以被拆分为两个部分
- 拆开的部分依旧是完全平方数
- `0`, `00`, `000`之类的不算完全平方数
- `025`这样的可以算完全平方数

一个简单的思路是我们可以**枚举区间内所有完全平方数 `N` ，然后检查 `N` 是否满足拼接条件**。这里的难点在如何检查：
1. 将 `N` 转化为字符串 `s`。
2. 遍历所有可能的分割点，将其分割为两个字串 `s1` 和 `s2`。注意，拆分出的两部分不能为空
3. 将子串 `s1` 和 `s2` 重新转化回数字。这里要注意细节，==`9025` 这样的数字可以拆开成 `9` 和 `025`==。**`stoll`或者`from_chars`这类标准转化函数可以正确地将`025`解析为25，符合题意。**
4. 判断是否都是==非零的完全平方数==。

> [!SUCCESS] Code

```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:29:09
 @Mail:        apollomonasa@gmail.com
 @Description: AtCoder template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

bool is_perfect_square(ll n) {
    if (n <= 0) {
        return false;
    }
    ll root = round(sqrt(n));
    return root * root == n;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    
    ll a, b;
    cin >> a >> b;

    for (ll i = 1; ; ++i) {
        ll n = i * i;
        if (n > b) {
            break;
        }
        if (n >= a) {
            string s = to_string(n);
            if (s.length() < 2) {
                continue;
            }

            // string_view sv(s);
            for (size_t k = 1; k < s.length(); ++k) {
                // string_view sv1 = sv.substr(0, k);
                // string_view sv2 = sv.substr(k);
                string s1 = s.substr(0, k);
                string s2 = s.substr(k);

                ll n1 = 0, n2 = 0;
                // from_chars(sv1.data(), sv1.data() + sv1.size(), n1);
                // from_chars(sv2.data(), sv2.data() + sv2.size(), n2);
                n1 = stoll(s1);
                n2 = stoll(s2);
                if (is_perfect_square(n1) && is_perfect_square(n2)) {
                    cout << n << "\n";
                    break;
                }
            }
        }
    }
    return 0;
}

```

## P8699 [蓝桥杯 2019 国 B] 排列数
> [点击此处跳转](https://www.luogu.com.cn/problem/P8699)

> [!NOTE] 考点
> 动态规划


先看看题面中的定义：
- 折点: 一个元素同时大于或小于旁边的元素。**==>** ==序列的头和尾不能是折点==
- k单调排列：包含 `k - 1` 个折点的排列

### 动态规划设计
> 所谓动态规划，就是设计一个函数的自变量，让这个自变量可以涵盖问题的条件，称之为状态定义，把目标状态输入函数即可得到想要的答案，可是我们只能直接想到简单状态的答案，要想获得复杂状态的答案怎么办呢？我们可以使得我们设计的状态能够转移，即通过简单状态可以递推下去获得想要的状态。举一个简单的例子，在跳台阶问题中，我们可以一步跳1阶，也可以一步跳2阶，那么跳上n阶台阶有多少种跳法？如果定义dp[i]表示跳上i阶台阶的方法数量，那么可以想到 `dp[i] = dp[i - 1] + dp[i - 2]` (我们可以从 `i - 1` 阶跳上 `i` 阶，或者从 `i - 2` 阶跳上 `i` 阶)，又不难想到 `dp[1] = 1, dp[2] = 2`，这叫`基本状态`，我们可以以此为起点一步步推到dp[n]。

而本题这类排列结构的计数问题，通常采用逐个插入数字的动态规划方法。

#### 状态定义
设 `dp[i][j]` 表示 `1 ~ i` 的排列中 `j单调排列`数量

#### 状态转移
> 刚刚我们探讨了一种 `找来源` 的状态转移思考方式，那这里我们就来演示一种 `寻去处` 的思考方式。

假设 `dp[i][j]` 的值已知，它可以影响到哪些状态? 那必然是插入更多数字的状态，这些状态或直接或间接被 `dp[i][j]` 影响， 但是我们只需要知道直接影响的状态，以及如何转移？

我们分析一下再插入 `i+1` 的情况：
> 这个数字是全场最大，插入就是一个折点(除非放在头部或者尾部)，也就是说它能制造一个$ \land $形状

1. **单调段数量不变**，我们可以把这个数插入到原排列的**每一个单调子段的较大的一端**来实现，所以有 `j` 种
2. **单调段数量+1**，只能放在头部或者尾部，比如如果头部是单调递减，我们可以放在第二个位置，如果是单调递增就放在第一个位置；如果尾部是单调递减就放在最后一个，如果是单调递增就放在倒数第二个位置。
3. **单调段数量+2**，排除以上情况都是。

所以最终的递推式是这样的:
$$
\begin{align}
&dp[i + 1][j] += dp[i][j] * j \newline
&dp[i + 1][j + 1] += dp[i][j] * 2 \newline
&dp[i + 1][j + 2] += dp[i][j] * (i - 2 - (j - 1))
\end{align}
$$

> [!SUCCESS] Code
```cpp
/*
 @Author:      ApolloMonasa
 @Date:        2025-11-29 21:28:57
 @Mail:        apollomonasa@gmail.com
 @Description: Codeforces template
*/
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using u128 = __uint128_t;
using namespace std;

const int MOD = 123456;

void slv(){
    int n, k;
    cin >> n >> k;

    if (k > n || k < 1) {
        cout << 0 << endl;
        return;
    }

    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));

    //  dp[i][j]表示 1~i的排列中k单调排列的数量
    dp[1][1] = 1;

    for (int i = 2; i < n; i++) {
        dp[i][1] = 2;
        for (int j = 1; j < i; j++) {
            dp[i + 1][j] \+= dp[i][j] * j % MOD;
            dp[i + 1][j + 1] \+= dp[i][j] * 2 % MOD;
            dp[i + 1][j + 2] \+= dp[i][j] * ((i + 1) - 2 - j)  % MOD;
        }
    }

    
    
    cout << dp[n][k] % MOD << endl;
}

int main(){
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);std::cout.tie(nullptr);
    // int t; std::cin >> t;
    // while(t--) slv();
    slv();
    return 0;
}
```
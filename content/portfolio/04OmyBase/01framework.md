---
title: "数据库项目整体框架"
tags: ["Database"]
weight: 10
draft: false
toc: true
date: 2025-11-03T13:00:02+08:00
---

> 2025年10月，我报名了OceanBase数据库大赛，可是学业太过繁重，事情堆在一起，无暇参赛，我的队友也是，他们也是比较摆的，来年我一定要自己参赛，但是我发现OceanBase不是他们宣传的那样从0开始，零基础的人听他们的课程根本听不太懂，所以，我在同年11.4决定启动这个项目，决定实现一个自己的数据库，项目名称很好想，张口就来："Oh!My Base!"，简称为**OmyBase**。

## 项目目标

注意，我做这个项目的目的不是为了备赛，而是学习数据库，我认为OceanBase真的不行，教程写得一坨，上课教得一般，没人带路，这个时候我想到了国外社区的活跃性，决定从国外的数据库开始学习。目前这个项目的下面部分还是AI生成，我们初步打算开发一遍CMU上面的演示DB，而不是直接上手开发自己的OmyBase。

#### **1. 项目概述 (Project Overview)**

*   **项目名称:** Oh!My Base! (简称: **OmyBase**)
*   **项目愿景:** 创建一个现代、开源、遵循SQL:2016标准的关系型数据库。本项目首先是一个学习工具，旨在深入探索数据库内核的实现原理；其次，它致力于成为一个功能完备、性能可靠、易于拓展的数据库系统。
*   **核心理念:** 以“第一性原理”为指导，不畏造轮子。我们坚信，亲手实现核心模块是掌握技术的最佳路径。
*   **主要学习对象:** **PostgreSQL 16**。我们将深入研究其成熟的架构，包括但不限于：
    *   进程/线程模型 (Process/Thread Model)
    *   多版本并发控制 (MVCC)
    *   预写式日志 (WAL) 与恢复机制
    *   可扩展的存储和索引系统
    *   先进的查询优化器
*   **次要参考:**
    *   **MySQL 8.0:** 学习其在高并发场景下的线程池模型和InnoDB存储引擎的特定实现。
    *   **ClickHouse:** 在项目后期，参考其列式存储和向量化执行引擎，为OmyBase增加分析查询(AP)的能力。

#### **2. 核心架构设计 (Core Architectural Design)**

这是整个项目的基石。我们将OmyBase设计为一个经典的多层次架构，与PostgreSQL高度相似。

  
*(这是一个典型的数据库架构图，我们将以此为蓝本进行设计)*

**2.1 客户端/服务器通信层 (Client/Server Communication)**

*   **协议:** 采用 **gRPC**。这能自动处理跨语言的客户端/服务器通信、序列化和网络传输细节，让我们专注于数据库逻辑。
*   **接口定义:** 定义核心`.proto`文件，明确API，如 `ExecuteQuery`, `FetchResults`, `BeginTransaction`, `Commit`, `Rollback`。
*   **兼容性:** 长期目标是实现PostgreSQL或MySQL的有线协议，以便复用现有的驱动程序和工具（如psql, DBeaver），但初期gRPC能让我们快速迭代。

**2.2 查询处理器 (Query Processor)**

这是SQL语句从文本到最终结果的旅程，是数据库的“大脑”。

1.  **解析器 (Parser):**
    *   **功能:** 将SQL文本字符串转换为抽象语法树 (AST)。
    *   **技术:** 可以使用经典的 `Flex` (词法分析) 和 `Bison` (语法分析) 工具，或者寻找现代的C++解析器生成库。

2.  **分析器/重写器 (Analyzer/Rewriter):**
    *   **功能:** 检查AST的语义正确性（表、列是否存在，数据类型是否匹配等），并将其转换为内部的查询树(Query Tree)。此阶段还会进行视图展开等操作。

3.  **优化器 (Optimizer):**
    *   **功能:** 数据库的性能核心。接收查询树，生成最优的**执行计划 (Execution Plan)**。
    *   **实现路径:**
        *   **初期:** 实现基于规则的优化 (RBO)，例如，将 `*` 替换为具体的列名。
        *   **核心目标:** 实现基于成本的优化 (CBO)，需要统计数据（表大小、基数、直方图等）来估算不同执行路径的成本，并选择成本最低的那个。

4.  **执行器 (Executor):**
    *   **功能:** 解释并执行优化器生成的计划。
    *   **模型:** 采用经典的**Volcano/迭代器模型**。每个执行节点（如顺序扫描、索引扫描、连接、排序）都实现 `Next()` 接口，上层节点通过调用下层节点的 `Next()` 来获取元组(Tuple)，层层向上，直到最终产生结果。
    *   **关于LLVM:** 将基于LLVM的JIT编译作为**高级优化特性**。在V1.0之后，对于复杂计算或热点查询，可以将执行计划动态编译为本地机器码，消除解释执行的开销，极大地提升性能。

**2.3 事务管理器 (Transaction Manager)**

保证ACID特性的关键。

*   **并发控制 (Concurrency Control):** 明确采用 **MVCC (多版本并发控制)**。
    *   **核心机制:** 读操作不会阻塞写操作，反之亦然。每个事务都有一个“快照”，只能看到在它开始之前已经提交的数据。通过在每条记录（Tuple）上存储创建和删除它的事务ID来实现版本控制。
*   **日志与恢复 (Logging & Recovery):**
    *   **技术:** 实现 **WAL (Write-Ahead Logging)** 机制。所有对数据的修改都必须先写入日志文件，再应用到数据页上。
    *   **恢复:** 数据库崩溃重启后，通过重放(Redo)WAL日志来恢复已提交但未写入磁盘的事务，并回滚(Undo)未完成的事务，保证数据一致性。

**2.4 存储引擎 (Storage Engine)**

负责数据的物理存储和检索。

*   **内存管理器 (Memory Manager):**
    *   **核心组件:** **共享缓冲区 (Shared Buffer Pool)**。这是磁盘数据页在内存中的缓存。
    *   **页面替换策略:** 实现一个高效的页面替换算法，如`Clock-Sweep` (PostgreSQL所使用的LRU变种)。

*   **存储管理器 (Storage Manager):**
    *   **组织方式:** 数据在磁盘上以**数据页 (Page)** 的形式组织。多个页面组成一个文件（称为Heap File）。
    *   **数据布局:** 在页面内存放行记录（Tuple），并处理变长数据和行溢出（TOAST机制）。

*   **索引管理器 (Index Manager):**
    *   **首要目标:** 实现一个健壮的 **B-Tree索引**。这是关系型数据库最常用、最重要的索引结构。
    *   **接口:** 索引管理器需要提供 `Insert`, `Delete`, `Search` 等标准接口，并支持并发控制（如锁或更高级的并发B-Tree算法）。

#### **3. 技术选型 (Refined Tech Stack)**

*   **编程语言:** **C++ (推荐 C++17 或 C++20)**，利用其现代特性如智能指针、并发库等来提升开发效率和代码质量。
*   **查询执行模型:**
    *   **V1.0:** **Volcano/迭代器模型** (易于实现和理解)。
    *   **V2.0+:** 引入**基于LLVM的JIT编译**作为可选的执行后端。
*   **构建系统:** **CMake** (跨平台标准)。
*   **依赖管理:** **vcpkg** 或 **Conan**。
*   **网络通信:** gRPC (已确定)。
*   **容器化:** Docker & Docker Compose (用于开发和测试)，Kubernetes (用于未来部署)。
*   **版本控制:** Git & GitHub (已确定)。
*   **CI/CD:** GitHub Actions (已确定)。

#### **4. 项目规划 (A More Realistic & Phased Plan)**

这是单人独立开发项目，不存在团队，只有自己够强，才有资格参加比赛，不然队友纯纯搞你心态。

*   **阶段一: 项目启动与地基搭建 (2025.11 - 2025.12)**
    *   搭建GitHub仓库和CI/CD基本流程。
    *   完成**核心数据结构**定义：`Page`, `Tuple`, `Schema`。
    *   **目标:** 实现一个简单的**缓冲区管理器 (Buffer Manager)** 和 **磁盘管理器 (Disk Manager)**，能够读写磁盘上的页面。

*   **阶段二: 核心存储与执行引擎雏形 (2026.01 - 2026.03)**
    *   实现**堆表 (Heap Table)**，支持元组的顺序插入和迭代。
    *   **[里程碑]** 实现一个基本的**顺序扫描 (Sequential Scan)** 执行节点。
    *   开发一个简单的SQL解析器（能解析`CREATE TABLE`, `INSERT`, `SELECT * FROM table;`）。
    *   **目标:** 能够成功执行一条`SELECT`语句并从磁盘文件中读取数据打印在控制台。**此时暂不考虑事务和并发**。

*   **阶段三: 索引与查询优化 (2026.04 - 2026.06)**
    *   实现**B-Tree索引**，支持插入和点查询。
    *   在执行器中增加**索引扫描 (Index Scan)** 节点。
    *   开发一个极简的**查询优化器**，能够根据`WHERE`子句决定使用顺序扫描还是索引扫描。
    *   **[里程碑]** 能够在一个带索引的表上高效地执行点查询。

*   **阶段四: 事务与并发控制 (2026.07 - 2026.08)**
    *   **这是最难的部分。**
    *   实现**锁管理器 (Lock Manager)** 和基础的**事务上下文**。
    *   引入**WAL机制**，保证原子性和持久性。
    *   改造存储引擎以支持**MVCC**，为元组添加事务ID等元数据。
    *   **目标:** 实现基本的ACID特性，多个客户端并发读写时数据不会错乱。

*   **阶段五: V1.0 Alpha发布与完善 (2026.09)**
    *   集成gRPC，提供一个简单的CLI客户端。
    *   编写基础的文档和测试用例。
    *   修复已知关键Bug。
    *   **发布 OmyBase 1.0 Alpha 版本**。这个版本功能有限，但核心架构已经稳定。

